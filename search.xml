<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <url>%2F2019%2F04%2F28%2Fgdb%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;gdb是一款具有强大功能的调试工具，由GNU开源组织发布，在unix/linux操作系统下，是基于命令行的。所以要使用gdb，需要掌握相关命令才能完成对程序的调试，注意使用命令的缩写，可以提高调试效率。 &emsp;&emsp;可以通过gdb 文件名 来启动程序准备调试，也可以先进入gdb，然后输入file 文件名 。下面给出常用命令： 命令 缩写 说明 list l 显示多行源代码 break b 设置断点，程序运行到这会停止 info i 描述程序的状态 run r 开始运行程序 display disp 跟踪查看某个变量，每次停下来都显示它的值 step s 执行下一跳语句，可以进入函数执行 next n 执行下一跳语句，跳过函数 print p 打印内部变量的值 continue c 继续程序的运行，直到下一个断点 set varname=v 设置变量的值 stat st 开始执行程序，在main函数的第一条语句前停下来 file 装入需要调试的程序 kil k 终止正在调试的程序 watch 监视变量值的变化 backtrace bt 查看函数调用信息 frame f 查看栈帧 quit q 退出gdb &emsp;&emsp;补充一个x命令，官方帮助将文档： Examine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string) and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format. &emsp;&emsp;通常使用x命令来查看内存地址中的值，x命令的语法：x/&lt;n/f/u&gt; ,addr. n、f、u是可选的参数。 n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。 f 表示显示的格式。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。 表示一个内存地址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[BasicFileInclude]]></title>
    <url>%2F2019%2F04%2F27%2FBasicFileInclude%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;说实话，对这种题没有一点儿经验，全靠各种搜集资料、、、 &emsp;&emsp;刚开始解这个题，点进链接里，看到这么一句话：ha ha? you want flag? flag is here, but don’t let you see! 。flag就在这儿，但是不让你看到。立马就查看源代码，本以为能从网页源码中发现什么线索，但是研究了好一会儿都没发现什么猫腻。又返回主界面寻找线索，题目名称为BasicFileInclude，基础文件包含，还有一打开这个题，就有的提示：Basic PHP File Inclusion vulnerability, try to get the flag.说是基础的文件包含漏洞。那么这道题就是和php文件包含漏洞有关系了，如果能找到这个漏洞，加以利用，应该就就可以解决了吧。 &emsp;&emsp;没有别的办法，只好去baidu，去google，以“php文件包含漏洞”为关键词进行搜索，发现了php伪协议这个名字，然后继续查看又发现可以利用php://filter达到目的。&emsp;&emsp;flag页面ip地址：http://123.207.149.64:23338/?page=flag ，在page=后加上下面的代码 1php://filter/read=convert.base64-encode/resource= 然后访问，在页面上出现了一大串经过base64加密的字符串，经过在线解密，得到了flag。这才发现为什么说flag就在这儿，原来是在&lt;?php?&gt;中给注释掉了。&emsp;&emsp;进一步了解，php://filter是php语言中特有的协议流，作用是作为一个中间流来处理其他流，有四个参数： 名称 描述 备注 resource=&lt;要过滤的数据流&gt; 指定了要筛选过滤的数据流。 必选 read=&lt;读链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符（丨）分割。 可选 write=&lt;写链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符（丨）分割。 可选 &lt;;两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 &emsp;&emsp;在无法通过查看源码得到有效信息时，可以尝试使用php://filter获取源码，也可以用来绕开关键限制。额，其实我对这个东西还不理解不深入，我还需要在研究研究才行。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[304号challenge_01]]></title>
    <url>%2F2019%2F04%2F26%2F304%E5%8F%B7challenge-01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;通过文件下载地址，下载下来一个压缩包，解压得到两个文件：myvm和hello。myvm是一个基于寄存器的虚拟机实现，可以解释执行任意一段与当前指令集相符的程序，hello就是可以被myvm解释执行的一段指令。 &emsp;&emsp;文档中给出了三个任务： 对myvm进行分析，理解其指令格式，取址方式。了解指令用法。 基于对myvm的理解写出对应的反汇编器。 对hello程序进行分析，理解hello程序所做的所有事情，并将上述整个过程总结为一篇研究报告。 &emsp;&emsp;那么，就先对myvm的main函数的大体框架分析一下。使用IDA对myvm进行反汇编，并生成伪代码： 1234567891011121314151617181920212223242526272829__int64 __usercall main@&lt;rax&gt;(char **a1@&lt;rsi&gt;, char **a2@&lt;rdx&gt;, __int64 a3@&lt;rax&gt;, int a4@&lt;edi&gt;)&#123; __int64 *v4; // rbx int v5; // eax if ( a4 == 2 ) &#123; signal(2, (__sighandler_t)handler); v4 = (__int64 *)sub_CE0(a1[1]); unk_202014 = 1; while ( 1 ) &#123; v5 = sub_E90(v4); if ( v5 ) break; if ( !unk_202014 ) goto LABEL_8; &#125; if ( v5 == 2 ) puts("Illegal Instruction");LABEL_8: nullsub_1(v4); &#125; else &#123; fprintf(stderr, "Usage: %s &lt;myvm program&gt;\n", *a1, a3); &#125; return 0LL;&#125; &emsp;&emsp;main函数的中体是一个if…else…分支，如果变量a4不等于2，则调用fprintf()函数，在此处fprintf(stderr, &quot;Usage: %s &lt;myvm program&gt;\n&quot;, *a1, a3); 应该是打印信息到屏幕上，*a1是main函数中的第一个参数，a1是二位字符串数组名，a3是int型变量。感觉a4应该是记录main函数参数个数的变量，如果main函数有两个参数，则正常执行，如果参数不是两个，则在屏幕上打印输出相应的信息，执行完毕fprintf()后程序结束。 &emsp;&emsp;如果a4等于2，则先执行signal函数，该函数的的第二个参数是函数handler。signal函数用于设置某一信号的对应动作，有两个参数。第一个参数知名所要处理的信号类型，可以取除了SIGKILL（杀死进程）和SIGSTOP（终止进程）外的任何一种信号，第二个参数描述信号关联的动作，可以取三种值：一个无返回值的函数地址、SIG_IGN（忽略该信号）和SIG_DEF（恢复系统对信号的默认处理）。 &emsp;&emsp;接下来执行函数sub_CE0，返回值由v4接收。将unk_202014赋值为1，进入一个死循环，循环体中，调用sub_E90函数，v4为参数，v5接收返回值，如果v5为0则继续执行，当v5非0时，循环终止，此时如果v5值为2，就输出”Illegal Instruction”。当unk_202014取0的时候也能跳出死循环，转而执行nullsub_1函数。 &emsp;&emsp;终究是伪代码，可读性远远比不上“真代码”，抽空再继续研究研究main函数，并分析其他函数。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机网络问题]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天打算搞一搞304号challenge的，已经拿到题目有几天了，但是一点儿头绪没有，计划今天好好研究研究，但是打开虚拟机，发现虚拟机联网出现了问题，搞了好一通。 &emsp;&emsp;在304challenge的文档中，有一个下载资料的网址，需要翻墙才可以访问，还有一个说是公网可访问的示例nc 106.14.12.250 20188 在kali中尝试访问，结果提示无法访问：起初以为是终端的问题，后来打开浏览器同样不能访问网页，才想到应该是虚拟机设置出现了问题，之前一直好好的，不知道什么原因引发的。 &emsp;&emsp;经过搜索，发现有类似问题的经验贴，按照帖子的步骤，在VMware的虚拟网络编辑器中恢复默认设置，然后打开虚拟设置，将网络适配器设置了一下，重启就ok了，可以正常访问网页，在文章结尾会放上参考贴的链接。 &emsp;&emsp;但是在使用过程中，发现主机使用shadowsocks科学上网，即便是开了全局代理，虚拟机中的kali仍然不能访问外网，于是又着手解决这个问题。相关操作有很多，这里只记录一下我使用的方法。 启动shadowsocks保证主机是可以访问外网的。 win+r快捷键+cmd调用命令行，输入ipconfi /all查看本地ip地址。 虚拟机中网络适配器设置为NAT模式 打开shadowsocks，查看所用代理服务器的代理端口，一般应该是1080。 设置代理为手动 进入网络设置，将Network Proxy中的所有ip和端口，设置成本地ip和1080. 最后，一定要将shadowsocks的“允许其他设备连入”打勾，一开始因为没有勾选，尝试了好一会都没能成功。 参考博客链接： https://blog.csdn.net/m0_37259197/article/details/78221016 https://blog.csdn.net/AcSuccess/article/details/76165245 https://blog.csdn.net/u010726042/article/details/53187937/]]></content>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习笔记03]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%2F</url>
    <content type="text"><![CDATA[3.寄存器（内存访问）3.1 内存中字的存储&emsp;&emsp;CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。 &emsp;&emsp;字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。 &emsp;&emsp;存储单元：可以存储以Byte，即8个二进制位。一个字单元占用两个存储单元。 3.2DS和[address]&emsp;&emsp;8086CPU中的DS寄存器，通常用来存放要访问的数据的段地址，下面给出一个从内存单元中读取数据的代码：123mov bx,1000Hmov ds,bxmov al,[0] 上面的3条指令将10000H（1000:0）中的数据读到寄存器al中。因为8086CPU不支持将数据直接送人段寄存器，需要用一个寄存器来进行中转，即先将数据读入一个一般的寄存器中，在将寄存器中的数据送入ds。所以mov bx,1000H和mov ds,bx 这两条指令，将段地址设为1000H，[0]表示内存单元的偏移地址为0，在指令执行时，8086CPU自动取ds中的数据为内存单元的段地址，使用mov al,[0]便实现了从内存单元10000H读数据。 3.3 mov、add、sub指令&emsp;&emsp;mov指令可以有以下几种形式： 12345678mov 寄存器，数据mov 寄存器，寄存器mov 寄存器，内存单元mov 内存单元，寄存器mov 内存单元，段寄存器mov 段寄存器，内存单元mov 段寄存器，寄存器mov 寄存器，段寄存器 &emsp;&emsp;add和sub指令和mov一样，都有连个操作对象，也可以有以下几种形式。 12345678add 寄存器，数据add 寄存器，寄存器add 寄存器，内存单元add 内存单元，寄存器sub 寄存器，数据sub 寄存器，寄存器sub 寄存器，内存单元sub 内存单元，寄存器 3.4数据段&emsp;&emsp;在编程时，可以根据需要，将一组内存单元定义为一个段，将一组长度为N（N&lt;=64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。用ds存放数据段的段地址，根据需要，用相关指令访问数据段中的具体单元。 3.5栈与栈机制&emsp;&emsp;CPU的栈与数据结构中的栈类似，具有后入先出的特点。栈有两个基本的操作：入栈（PUSH）和出栈（POP）。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。8086CPU在编程的时候，可以将一段内存当栈来使用。栈顶的段地址存放在段寄存器SS中，偏移地址存放在寄存器SP中，任意时刻，SS：SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。 &emsp;&emsp;8086CPU提供栈操作机制，方案如下： 在SS、SP中存放栈顶的段地址和偏移地址； 提供入栈和出栈指令，根据SS：SP指示的地址，按照栈的方式访问内存单元。 &emsp;&emsp;push ax的执行： SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶； 将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶。 &emsp;&emsp;pop ax的执行： 将SS：SP指向的内存单元处的数据送入ax中； SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 &emsp;&emsp;另外，8086CPU只记录栈顶，栈空间的大小我们要自己管理。 3.6 push、pop指令 格式 含义 push 寄存器 将一个寄存器中的数据入栈 pop 寄存器 出栈，用一个寄存器接收出栈的数据 push 段寄存器 将一个段寄存器中的数据入栈 pop 段寄存器 出栈，用一个段寄存器接收出栈的数据 push 内存单元 将一个内存单元处的字入栈（栈操作都是以字为单位） pop 内存单元 出栈，用一个内存单元接收出栈的数据 &emsp;&emsp;push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS：SP指出的。同时，push和pop指令还有改变SP中的内容。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习笔记02]]></title>
    <url>%2F2019%2F04%2F23%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%2F</url>
    <content type="text"><![CDATA[2.寄存器&emsp;&emsp;一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。在CPU中： 运算器进行信息处理； 寄存器进行信息存储； 控制器控制各种器件进行工作； 内部总线连接各种器件，在它们之间进行数据的传送。 &emsp;&emsp;8086CPU有14个寄存器，分别是AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。 2.1通用寄存器&emsp;&emsp;8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX通常用来存放一般性数据，被称为通用寄存器。同时，AX可分为两个独立使用的8位寄存器AH和AL，AX的低8位（0-7）构成AL寄存器，高8位（8-15）构成，其他同理。 2.2字在寄存器中的存储&emsp;&emsp;8086CPU可以一次性处理以下两种尺寸的数据： 字节：记为byte，一个字节由8个bite组成，可以存在8位寄存器中。 字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。 &emsp;&emsp;一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节就存在这个寄存器的高8位寄存器和低8位寄存器中。 2.3几条汇编指令 汇编指令 控制CPU完成的操作 用高级语言的语法描述 mov ax,18 将18送入寄存器AX AX=18 mov ah,78 将78送入寄存器AH AH=78 add ax,8 将寄存器AX中的数值加上8 AX=AX+8 mov ax,bx 将寄存器BX中的数据送入寄存器AX AX=BX add ax,bx 将AX和BX中数据相加，结果存在AX中 AX=AX+BX &emsp;&emsp;在进行数据传送或运算时，指令的两个操作对象的位数应当是一致的，只能在同位寄存器中进行数据的传送。注意：在运算中AH和AL是完全独立互不影响的。例如：ax=00C5H,执行add al,93H 得到的结果为ax=0058H，al+93H的进位并不会保存到ah中。 2.4 16为结构的CPU&emsp;&emsp;8086是16位结构的CPU，具有 如下特性： 运算器一次最多可以处理16位的数据； 寄存器的最大宽度为16位； 寄存器和运算器之间的通路为16位。 2.5 8086CPU给出物理地址的方法&emsp;&emsp;所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。 &emsp;&emsp;8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力，但是8086CPU是16位结构，在内部一次性处理、传输、暂时存储的地址为16位，如果将地址从内部简单地发出，只能送出16位的地址，表现出的寻址能力只有64KB。所以8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位物理地址。 CPU中的相关部件提供两个16位的地址，一个称为短地址，另一个称为偏移地址； 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件； 地址加法器将两个16位地址合成为一个20位的物理地址； 地址加法器通过内部总线将20位物理地址送入输入输出控制电路； 输入输出控制电路将20位物理地址送上地址总线； 20位物理地址被地址总线传送到存储器。 &emsp;&emsp;地址加法器采用物理地址=段地址*16+偏移地址的方法，用段地址和偏移地址合成物理地址。其本质含义是：CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。 2.6段寄存器&emsp;&emsp;段寄存器存放段地址，8086CPU有4个段寄存器：CS、DS、SS、ES。 &emsp;&emsp;CS为代码段寄存器，IP为指令指针寄存器。在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行。 &emsp;&emsp;8086CPU工作过程简要描述： 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器； IP=IP+所读取指令的长度，从而指向下一条指令； 执行指令。转到步骤1，重复这个过程。 2.7修改CS、IP的指令&emsp;&emsp;可以使用mov指令修改通用寄存器的值，mov ax,123 将ax中的值设为123.mov指令被称为传送指令。但是mov指令不能用于设置CS、IP的值。 &emsp;&emsp;能够改变CS、IP的内容的指令被统称为转移指令，例如jmp指令。若想同时修改CS、IP的内容，可用jmp 短地址:偏移地址 类型的指令完成。如jmp 2AE3:3执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H出读取指令。“jmp 短地址：偏移地址”指令的功能为：用指令中给出的短地址修改CS，偏移地址修改IP。 &emsp;&emsp;若想仅修改IP的内容，可用刑辱“jmp 某一合法寄存器”的指令来完成，如： jmp ax，指令执行前：ax=1000H，CS=2000H，IP=0003H &emsp;&emsp;&emsp;&emsp;指令执行后：ax=1000H，CS=2000H，IP=1000H jmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H &emsp;&emsp;&emsp;&emsp;指令执行后：bx=0B16H，CS=2000H，IP=0B16H &emsp;&emsp;“jmp 某一合法寄存器”指令的功能为：用寄存器中的值修改IP。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言学习笔记01]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;打算今天开始系统性学习汇编语言，使用教材为王爽老师编写的《汇编语言（第三版）》，会将自己认为重要的知识点整理下来，以加深印象，且便于日后回顾查阅。 1.基础知识1.1所谓汇编&emsp;&emsp;机器语言是机器指令的集合，是一列二进制数字，相当难记忆，使用起来很麻烦，所以就诞生了汇编语言。汇编语言的主题是汇编指令，汇编指令是机器指令便于记忆的书写格式。我们可以用汇编指令编写源程序，然后通过编译器将汇编指令转换成机器指令，由计算机最终执行。 1.2汇编语言的组成（1）汇编指令：机器码的助记符，有对应的机器码。 （2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。 （3）其他符号：入+、-、*、/等，由编译器识别，没有对应的机器码。 1.3指令和数据&emsp;&emsp;课本中在介绍指令和数据时，只提到了指令和数据没有任何区别，都是二进制信息，CPU在工作的时候可以自己区分，为同样的信息赋予不同的意义。这里根据自己的积累和理解补充一下，一般计算机都是采用冯诺依曼结构，将指令和数据不是分开存储，而是都以二进制的形式放在存储器中，CPU可以根据指令周期的不同阶段来区分是指令还是数据。通常在取指阶段取出的是指令，在执行阶段取出的是数据。 &emsp;&emsp;另外，指令和数据只在存储器中存放的，也就是在内存中。磁盘不同于内存，磁盘上的数据或程序如果不读入内存中，就无法被CPU使用。 1.4存储单元&emsp;&emsp;存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit（比特），也就是一个二进制位。8个bit组成一个Byte（字节）。微型机存储器的存储单元可以存储一个Byte，即8个二进制位。微机存储器的容量是以字节为最小单位来计算的。 1.5CPU对存储器的读写&emsp;&emsp;CPU要进行数据的读写，必须和外部期间进行3类信息交互： 存储单元的地址（地址信息）； 器件的选择，读或写的命令（控制信息）； 读或写的数据（数据信息）。 &emsp;&emsp;CPU通过导线与存储器交互，计算机中专门连接CPU和其他芯片的导线称为总线，总线在逻辑上又分为3类，地址总线、控制总线和数据总线。 1.6总线 CPU通过地址总线来指定存储器单元。CPU可以对多少个存储单元进行寻址，取决于地址总线上能传送多少个不同的信息，即地址总线的宽度决定了CPU的寻址能力。一个CPU有N根地址线，可以说这个CPU的地址总线宽度为N，最多可以寻找2的N次方个内存单元。 CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度，决定了与其他器件进行数据传送时的一次数据传送量。N根数据总线一次可传送一个N为二进制数据（N/8个字节）。 CPU对外部器件的控制通过控制总线来进行。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。控制总线的宽度决定了CPU对外部器件的控制能力。 1.7存储器与内存地址空间&emsp;&emsp;一台PC机装有多个存储芯片，从读写属性上，可以分为两类： 随机存储器（RAM）可读可写，必须带电存储，关机后存储的内容丢失； 只读存储器（ROM）只能读取不能写入，关机后其中内弄不丢失。 &emsp;&emsp;对CPU来讲，系统中的所有物理存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器就是我们所说的内存地址空间。每个物理存储器在逻辑存储器中占有一个地址段，即一段地址空间，CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basic_PHP]]></title>
    <url>%2F2019%2F04%2F21%2FBasic-PHP%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;思路通过题目页面中的php代码已经给出，顺着判断条件一步一步往下走，如果有一些基础经验的话会更好解决。 知识点铺垫 isset()在php中用来检测变量是否设置，该函数返回的是布尔值，即true/false。 $_GET变量用于收集来自method=”get”的表单中的值。通过get方式提交数据，变量名和值都会出现在地址栏的URL中。 md5(string)将一个字符串进行加密计算。 sha1也是一种加密算法：安全哈希算法。 梳理代码&emsp;&emsp;虽然没有学过php，但是有了上面的铺垫，再加上本身的编程基础，而且本题中的代码逻辑简单，理解起来还是很容易的。下面按照顺序简单梳理一下程序的内容。 首先判断name、password和test这三个变量是否设置，若已经设置，继续向下执行；否则直接退出，结束程序。 取出test并进行md5加密。 若test经加密后与0相等，通过阶段1，继续向下；否则结束。 如果name与password的值相等，结束。若不相等，,则继续向下执行。 如果name与password经sha1加密后相等，给出flag，否则退出当前脚本。 &emsp;&emsp;总结下来就是，需要设置好name、password和test这三个变量，test应满足经md5加密后与0相等，name与password应满足本身值不相同但经过sha1加密后相同。 解题过程&emsp;&emsp;经过上面的分析，解题的方法已经很明确了，就是寻找一个经md5加密后与0相等的字符串，还要寻找两个本身值不相同，但是经过sha1加密后相等的字符串。 &emsp;&emsp;先从test开始入手，经查阅知，只要一个字符串md5加密后32位密文的开头为0e，即可使md5(string)==’0’成立，这样字符串有不少，简单列举几个，经测试都有效： 字符串 md5加密后（32位） 240610708 0e462097431906509019562988736854 aabg7XSs 0e087386482136013740957780965295 aabC9RqS 0e041022518165728065344349536299 s1836677006a 0e481036490867661113260034900752 &emsp;&emsp;sha1()函数要求传入的参数是字符串类型，如果传入两个数组类型，结果就都是FALSE,就相等了，这样name与password的解决方法也有了。 &emsp;&emsp;通过get方式提交数据，直接在URL中追加变量和属性即可，于是构造如下地址：1http://123.207.149.64:23331/feature/?name[]=1&amp;password[]=2&amp;test=s1836677006a 正常访问即可获得flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse_sign_in]]></title>
    <url>%2F2019%2F04%2F20%2FReverse-sign-in%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;给了一个Linux下可执行的rev1文件，输入命令objdump -d rev1 &gt; rev1.txt 将它的汇编代码放到rev1.txt文件中，然后gdb rev 将rev给run了一下，运行中让输入flag，那么正确的flag应该就是此处要输入的。看了看汇编代码，嗯，不够直观，于是把rev在IDA中打开，将主函数生成伪代码，进行分析。伪代码如下： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 result; // rax char s; // [rsp+0h] [rbp-30h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); printf("Please input your flag:", a2, a3); __isoc99_scanf("%32s", &amp;s); if ( strlen(&amp;s) == 32 ) &#123; if ( (unsigned int)sub_400686((__int64)&amp;s) ) puts("Right!"); else puts("Wrong!"); result = 0LL; &#125; else &#123; puts("Wrong!"); result = 0LL; &#125; return result;&#125; &emsp;&emsp;只有当字符串s的长度为32且sub_400686()函数的返回值非0时，才会输出”Right”，答案应该在这个函数中寻找，跳转到这个函数的伪代码： 1234567891011signed __int64 __fastcall sub_400686(__int64 a1)&#123; signed int i; // [rsp+Ch] [rbp-Ch] for ( i = 0; i &lt;= 31; ++i ) &#123; if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i ) return 0LL; &#125; return 1LL;&#125; 其中byte_400818是一个数组：该函数的大概意思是，将字符串中下标i的字符与数组中下标为i的数进行异或运算，要保证结果与下标i相等。所以可以根据这个函数写个代码来反向求出字符串。另外，2dup(60h)表示两个十六进制数0x60。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int i; char a[32]; int b[]=&#123;0x66,0x6d,0x63,0x64,0x7f,0x3c,0x36,0x72,0x57,0x42, 0x64,0x3b,0x7b,0x52,0x7c,0x3c,0x66,0x54,0x60,0x60, 0x27,0x4a,0x49,0x7f,0x71,0x58,0x52,0x72,0x7d,0x75, 0x2a,0x62&#125;; for(i=0;i&lt;=31;i++) a[i]=(char)b[i]^i; for(i=0;i&lt;=31;i++) cout&lt;&lt;a[i]; cout &lt;&lt; endl; return 0;&#125; &emsp;&emsp;运行一下，即可打印输出flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge：二进制炸弹07]]></title>
    <url>%2F2019%2F04%2F19%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B907%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;任务书中指出，第四关中输入特定字符串可以进入隐藏关，所以找一找。 寻找入口&emsp;&emsp;在asm.txt文件中查找”secret_phase”关键字，在”phase_defused”函数中发现隐藏关的入口。123456789101112131415161718192021222324252627282930313233343536373839404108049286 &lt;phase_defused&gt;: 8049286: 81 ec 8c 00 00 00 sub $0x8c,%esp 804928c: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8049292: 89 44 24 7c mov %eax,0x7c(%esp) 8049296: 31 c0 xor %eax,%eax 8049298: 83 3d c8 c3 04 08 06 cmpl $0x6,0x804c3c8 804929f: 75 72 jne 8049313 &lt;phase_defused+0x8d&gt; 80492a1: 8d 44 24 2c lea 0x2c(%esp),%eax 80492a5: 89 44 24 10 mov %eax,0x10(%esp) 80492a9: 8d 44 24 28 lea 0x28(%esp),%eax 80492ad: 89 44 24 0c mov %eax,0xc(%esp) 80492b1: 8d 44 24 24 lea 0x24(%esp),%eax 80492b5: 89 44 24 08 mov %eax,0x8(%esp) 80492b9: c7 44 24 04 69 a3 04 movl $0x804a369,0x4(%esp) 80492c0: 08 80492c1: c7 04 24 d0 c4 04 08 movl $0x804c4d0,(%esp) 80492c8: e8 93 f5 ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; //返回输入的参数个数 80492cd: 83 f8 03 cmp $0x3,%eax 80492d0: 75 35 jne 8049307 &lt;phase_defused+0x81&gt; //如果输入的不是3个变量就无法进入隐藏关 --&gt; 80492d2: c7 44 24 04 72 a3 04 movl $0x804a372,0x4(%esp) //gdb x/sb 0x804a372 =&gt; DrEvil 第四个关输入“2 13 DrEvil”即可解锁隐藏关 80492d9: 08 80492da: 8d 44 24 2c lea 0x2c(%esp),%eax 80492de: 89 04 24 mov %eax,(%esp) 80492e1: e8 24 fd ff ff call 804900a &lt;strings_not_equal&gt; 80492e6: 85 c0 test %eax,%eax 80492e8: 75 1d jne 8049307 &lt;phase_defused+0x81&gt; //如果不相等也不能进入隐藏关 --&gt; 80492ea: c7 04 24 38 a2 04 08 movl $0x804a238,(%esp) 80492f1: e8 fa f4 ff ff call 80487f0 &lt;puts@plt&gt; 80492f6: c7 04 24 60 a2 04 08 movl $0x804a260,(%esp) 80492fd: e8 ee f4 ff ff call 80487f0 &lt;puts@plt&gt; 8049302: e8 ec fb ff ff call 8048ef3 &lt;secret_phase&gt; //这个地方调用隐藏关 8049307: c7 04 24 98 a2 04 08 movl $0x804a298,(%esp) // &lt;-- 804930e: e8 dd f4 ff ff call 80487f0 &lt;puts@plt&gt; 8049313: 8b 44 24 7c mov 0x7c(%esp),%eax 8049317: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 804931e: 74 05 je 8049325 &lt;phase_defused+0x9f&gt; 8049320: e8 9b f4 ff ff call 80487c0 &lt;__stack_chk_fail@plt&gt; 8049325: 81 c4 8c 00 00 00 add $0x8c,%esp 804932b: c3 ret 804932c: 66 90 xchg %ax,%ax 804932e: 66 90 xchg %ax,%ax 通过分析得知，需要响应的字符串匹配成功才能进入隐藏关，根据提示加分析，了解到在第四关输入的两个数后面加上字符串”DrEvil”就可以获得进入隐藏关的通行证，隐藏关在第六关之后开启。 secret_phase汇编代码与分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626308048ea2 &lt;fun7&gt;: 8048ea2: 53 push %ebx 8048ea3: 83 ec 18 sub $0x18,%esp 8048ea6: 8b 54 24 20 mov 0x20(%esp),%edx //数组首地址 8048eaa: 8b 4c 24 24 mov 0x24(%esp),%ecx //这个数是输入的数字 8048eae: 85 d2 test %edx,%edx //test于je连用 如果edx=0 则跳转 8048eb0: 74 37 je 8048ee9 &lt;fun7+0x47&gt; //---&gt; 8048eb2: 8b 1a mov (%edx),%ebx //数组第一个数 8048eb4: 39 cb cmp %ecx,%ebx 8048eb6: 7e 13 jle 8048ecb &lt;fun7+0x29&gt; //ecx&gt;=ebx(数组第一个元素) --&gt; 8048eb8: 89 4c 24 04 mov %ecx,0x4(%esp) 8048ebc: 8b 42 04 mov 0x4(%edx),%eax 8048ebf: 89 04 24 mov %eax,(%esp) 8048ec2: e8 db ff ff ff call 8048ea2 &lt;fun7&gt; 8048ec7: 01 c0 add %eax,%eax 8048ec9: eb 23 jmp 8048eee &lt;fun7+0x4c&gt; //----&gt; 8048ecb: b8 00 00 00 00 mov $0x0,%eax // &lt;-- 8048ed0: 39 cb cmp %ecx,%ebx 8048ed2: 74 1a je 8048eee &lt;fun7+0x4c&gt; //ecx和ebx相等 跳转到结束 ----&gt; 8048ed4: 89 4c 24 04 mov %ecx,0x4(%esp) 8048ed8: 8b 42 08 mov 0x8(%edx),%eax 8048edb: 89 04 24 mov %eax,(%esp) 8048ede: e8 bf ff ff ff call 8048ea2 &lt;fun7&gt; 8048ee3: 8d 44 00 01 lea 0x1(%eax,%eax,1),%eax 8048ee7: eb 05 jmp 8048eee &lt;fun7+0x4c&gt; 8048ee9: b8 ff ff ff ff mov $0xffffffff,%eax //返回-1 &lt;--- 8048eee: 83 c4 18 add $0x18,%esp // &lt;---- 8048ef1: 5b pop %ebx 8048ef2: c3 ret 08048ef3 &lt;secret_phase&gt;: 8048ef3: 53 push %ebx 8048ef4: 83 ec 18 sub $0x18,%esp 8048ef7: e8 90 02 00 00 call 804918c &lt;read_line&gt; //输入的字符从nptr 8048efc: c7 44 24 08 0a 00 00 movl $0xa,0x8(%esp) //base 十进制 8048f03: 00 8048f04: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) //endptr 8048f0b: 00 8048f0c: 89 04 24 mov %eax,(%esp) 8048f0f: e8 bc f9 ff ff call 80488d0 &lt;strtol@plt&gt; //long int strtol(const char *nptr,char **endptr,int base); 将字符串nptr转换从base进制的长整型数 base取2-36或0 8048f14: 89 c3 mov %eax,%ebx 8048f16: 8d 40 ff lea -0x1(%eax),%eax //eax-- 8048f19: 3d e8 03 00 00 cmp $0x3e8,%eax 8048f1e: 76 05 jbe 8048f25 &lt;secret_phase+0x32&gt; //小于等于时跳转 需要eax&lt;=0x3e8 （1000） 所以输入的数应小于1001 8048f20: e8 f0 01 00 00 call 8049115 &lt;explode_bomb&gt; 8048f25: 89 5c 24 04 mov %ebx,0x4(%esp) 8048f29: c7 04 24 88 c0 04 08 movl $0x804c088,(%esp) //0x804c088一个数组的起始地址 8048f30: e8 6d ff ff ff call 8048ea2 &lt;fun7&gt; //调用fun函数 8048f35: 83 f8 02 cmp $0x2,%eax //函数返回值和2比较 8048f38: 74 05 je 8048f3f &lt;secret_phase+0x4c&gt; //返回值需要等于2 eax=2 8048f3a: e8 d6 01 00 00 call 8049115 &lt;explode_bomb&gt; 8048f3f: c7 04 24 74 a1 04 08 movl $0x804a174,(%esp) //x/s 0x804a174 =&gt; Wow! You&apos;ve defused the secret stage提示成功拆除隐藏关炸弹 8048f46: e8 a5 f8 ff ff call 80487f0 &lt;puts@plt&gt; 8048f4b: e8 36 03 00 00 call 8049286 &lt;phase_defused&gt; 8048f50: 83 c4 18 add $0x18,%esp 8048f53: 5b pop %ebx 8048f54: c3 ret 8048f55: 66 90 xchg %ax,%ax 8048f57: 66 90 xchg %ax,%ax 8048f59: 66 90 xchg %ax,%ax 8048f5b: 66 90 xchg %ax,%ax 8048f5d: 66 90 xchg %ax,%ax 8048f5f: 90 nop secret_phase拆除&emsp;&emsp;在secret_phase函数中，strtol函数的原型是long int strtol(const char *nptr,char **endptr,int base);用于将字符串nptr转换从base进制的长整型数，base取2-36或0。若参数endptr不为null，则会将遇到不合条件而终止的nptr中的字符指针由endptr返回，若参数endptr为null，则不会返回非法字符串。经过分析可以得知要输入的数字是小于1001的，然后调用fun7函数，如果fun7函数的返回值是2那么这一关就成功拆除了。fun7函数中进行了递归，不容易理解，借助ida生成的伪代码辅助理解的。 &emsp;&emsp;使用gdb查看以0x804c088为起始地址的数组元素值： 然后将数组的数值挨个按下面的代码逻辑试了试，发现22能够满足fun7返回2的要求，然后进行尝试，成功拆除。 12345678910111213int __cdecl fun7(_DWORD *a1, int a2)&#123; int result; // eax if ( !a1 ) return -1; if ( *a1 &gt; a2 ) return 2 * fun7(a1[1], a2); result = 0; if ( *a1 != a2 ) result = 2 * fun7(a1[2], a2) + 1; return result;&#125; 对汇编程序的分析还是不到位，原因是对汇编的理解还是你不深入，还需要在深入学习，多多练习。所有阶段的答案：1234567When a problem comes along, you must zip it!0 1 3 6 10 150 8602 13 DrEvil5 1156 4 2 1 3 522 放一下最终通关的截图：]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge：二进制炸弹06]]></title>
    <url>%2F2019%2F04%2F18%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B906%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;不得不说这关好难搞。 phase_6汇编代码与分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828308048dcf &lt;phase_6&gt;://下面是一个大循环里套了个小循环 得出数组元素都小于等于6且互不相等 8048dcf: 56 push %esi 8048dd0: 53 push %ebx 8048dd1: 83 ec 44 sub $0x44,%esp 8048dd4: 8d 44 24 10 lea 0x10(%esp),%eax 8048dd8: 89 44 24 04 mov %eax,0x4(%esp) 8048ddc: 8b 44 24 50 mov 0x50(%esp),%eax 8048de0: 89 04 24 mov %eax,(%esp) 8048de3: e8 54 03 00 00 call 804913c &lt;read_six_numbers&gt; 8048de8: be 00 00 00 00 mov $0x0,%esi //esi=0 可以看作数组下标 8048ded: 8b 44 b4 10 mov 0x10(%esp,%esi,4),%eax //eax=（esp+4*esi+0x10） 访问数组元素 &lt;----- 8048df1: 83 e8 01 sub $0x1,%eax //eax-1 8048df4: 83 f8 05 cmp $0x5,%eax //eax和5比较 8048df7: 76 05 jbe 8048dfe &lt;phase_6+0x2f&gt; //小于等于时跳转 否则爆炸 也就是数组元素都小于等于6 8048df9: e8 17 03 00 00 call 8049115 &lt;explode_bomb&gt; 8048dfe: 83 c6 01 add $0x1,%esi //esi++ 8048e01: 83 fe 06 cmp $0x6,%esi //esi和6比较 8048e04: 75 07 jne 8048e0d &lt;phase_6+0x3e&gt; //esi不等于6跳转 --&gt; 8048e06: bb 00 00 00 00 mov $0x0,%ebx //ebx=0 8048e0b: eb 38 jmp 8048e45 &lt;phase_6+0x76&gt; //esi=6时 从这里跳出去 摆脱循环 ---》 8048e0d: 89 f3 mov %esi,%ebx // &lt;-- 8048e0f: 8b 44 9c 10 mov 0x10(%esp,%ebx,4),%eax //eax=（esp+4*ebx+0x10） &lt;---- 8048e13: 39 44 b4 0c cmp %eax,0xc(%esp,%esi,4) //eax != （esp+4*esi+0xc） 8048e17: 75 05 jne 8048e1e &lt;phase_6+0x4f&gt; //数组中各元素互不相同 8048e19: e8 f7 02 00 00 call 8049115 &lt;explode_bomb&gt; 8048e1e: 83 c3 01 add $0x1,%ebx //ebx++ 8048e21: 83 fb 05 cmp $0x5,%ebx 8048e24: 7e e9 jle 8048e0f &lt;phase_6+0x40&gt; //小于等于时转移 ebx&lt;=5时向上跳 ----&gt; 8048e26: eb c5 jmp 8048ded &lt;phase_6+0x1e&gt; //还是往上跳 跳的更高 走到这里就不能往下走 需要在上面某地跳转下去 -----&gt;//将起始地址为0x804c13c的6个结点地址取出 假设上面的提到的数组名为a下标为i（0-5） 则下面的代码是依次取第a[i]个节点的地址（由上可知a[i]&lt;=6 由下猜测最小应取1） 8048e28: 8b 52 08 mov 0x8(%edx),%edx // &lt;---- 8048e2b: 83 c0 01 add $0x1,%eax 8048e2e: 39 c8 cmp %ecx,%eax 8048e30: 75 f6 jne 8048e28 &lt;phase_6+0x59&gt; 8048e32: eb 05 jmp 8048e39 &lt;phase_6+0x6a&gt; 8048e34: ba 3c c1 04 08 mov $0x804c13c,%edx //将地址赋给edx &lt;-- 8048e39: 89 54 b4 28 mov %edx,0x28(%esp,%esi,4) //esp+4*esi+0x28（数组中元素地址从esp+0x10到esp+0x24 此处地址在从esp+0x28起 位置是排在数组的6个元素之后） 8048e3d: 83 c3 01 add $0x1,%ebx 8048e40: 83 fb 06 cmp $0x6,%ebx 8048e43: 74 17 je 8048e5c &lt;phase_6+0x8d&gt; //跳出循环 -----》 8048e45: 89 de mov %ebx,%esi // 在上面 ebx已经置0 《--- 8048e47: 8b 4c 9c 10 mov 0x10(%esp,%ebx,4),%ecx //esp+4*ebx+0x10 从数组第一个元素开始遍历 8048e4b: 83 f9 01 cmp $0x1,%ecx //ecx与1比较 8048e4e: 7e e4 jle 8048e34 &lt;phase_6+0x65&gt; //ecx&lt;=1时跳 --&gt; 8048e50: b8 01 00 00 00 mov $0x1,%eax 8048e55: ba 3c c1 04 08 mov $0x804c13c,%edx 8048e5a: eb cc jmp 8048e28 &lt;phase_6+0x59&gt; // ----&gt;//将前一个节点指向后一个节点 8048e5c: 8b 5c 24 28 mov 0x28(%esp),%ebx // 《------ 8048e60: 8d 44 24 2c lea 0x2c(%esp),%eax 8048e64: 8d 74 24 40 lea 0x40(%esp),%esi 8048e68: 89 d9 mov %ebx,%ecx 8048e6a: 8b 10 mov (%eax),%edx //取出6个节点的数值 &lt;--- 8048e6c: 89 51 08 mov %edx,0x8(%ecx) 8048e6f: 83 c0 04 add $0x4,%eax 8048e72: 39 f0 cmp %esi,%eax 8048e74: 74 04 je 8048e7a &lt;phase_6+0xab&gt; //跳出循环--》 8048e76: 89 d1 mov %edx,%ecx 8048e78: eb f0 jmp 8048e6a &lt;phase_6+0x9b&gt; //---&gt;//约定数值的顺序 非升序的方式排列 8048e7a: c7 42 08 00 00 00 00 movl $0x0,0x8(%edx) // 《-- 8048e81: be 05 00 00 00 mov $0x5,%esi 8048e86: 8b 43 08 mov 0x8(%ebx),%eax // &lt;---- 8048e89: 8b 00 mov (%eax),%eax 8048e8b: 39 03 cmp %eax,(%ebx) 8048e8d: 7d 05 jge 8048e94 &lt;phase_6+0xc5&gt; //前一个数要大于等于后一个数才能不爆炸 8048e8f: e8 81 02 00 00 call 8049115 &lt;explode_bomb&gt; 8048e94: 8b 5b 08 mov 0x8(%ebx),%ebx 8048e97: 83 ee 01 sub $0x1,%esi 8048e9a: 75 ea jne 8048e86 &lt;phase_6+0xb7&gt; //esi不等于1时继续循环----&gt; 8048e9c: 83 c4 44 add $0x44,%esp 8048e9f: 5b pop %ebx 8048ea0: 5e pop %esi 8048ea1: c3 ret phase_6拆除&emsp;&emsp;这一关的代码，可以分为四部分，详细的思考过程都在代码后面加注释了，太零散这里就不重复了，简要说一下大体功能。第一部分是大循环套了个小循环，约定了数组中元素的范围并且指出各元素互不相同，设这个数组名为a。通过第二部分可以发现6个结点，打印结点查看数值：在这6个结点中，依次取第a[i]个结点（下标i取1到6），组成链表，这个链表中的数值是非升序排列（因为6个结点的数值各不相同，所以也就是降序排列了）。根据这个规则，可以将6个结点的进行降序排列，然后得到我们需要的答案。下图是在word里做的一个结点排序前后的图：输入结果验证，正确。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言简单入门]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在做题中也搜集了解了些关于汇编的知识，了解了部分常用指令的功能，现在整理汇总一下目前所接触到的寄存器的相关知识，抽空还要系统性学习。另外，不同平台有不同的汇编语言对应，因为汇编和操作系统平台相关，以下为32位的80x86汇编语言知识点简要总结。 数据寄存器EAX、EBX、ECX和EDX&emsp;&emsp;IA-32架构中有4个32位数据寄存器，用于保存临时数据，分别是EAX、EBX、ECX和EDX。 &emsp;&emsp;这4个32位寄存器名字前都有一字母”E”，含义是”Expan”扩展，这是由于在16位的时代，这4个寄存器的名字是AX、BX、CX和DX，到了32位后就在它们名字前加”E”来区别是32位还是16位。 &emsp;&emsp;这4个32位寄存器可以当作16位使用，也可以当作8为使用。当作8位使用时，将AX拆开为AH和AL，”H”代表”High”，意思是高位，”L”代表”Low”，意思是低位。同理BX、CX和DX也可拆开为BH、BL、CH、CL、DH、DL来使用。 EAX寄存器：EAX称为累加器，常用于算数运算、布尔操作、逻辑操作、返回函数结果等。 EBX寄存器：EBX称为基址寄存器，常用于存档内存地址。 ECX寄存器：ECX称为计数寄存器，常用于存放循环语句的循环次数，字符串操作中也常用。 EDX寄存器：EDX称为数据寄存器，常和EAX一起使用。 &emsp;&emsp;上述的4个通用寄存的专门用途不是一成不变的，编译器在编译程序时会根据很多因素做出相应改变。 变址寄存器ESI和EDI&emsp;&emsp;变址的含义是内存地址是会变动的，也就是说变址寄存器中存放变动的内存地址。 ESI寄存器：称为源变址寄存器，通常存放要处理的数据的内存地址。 EDI寄存器：称为目的变址寄存器，通常存放处理后的数据的内存地址。 &emsp;&emsp;ESI和EDI常用来配合使用完成数据的赋值操作。 指针寄存器EBP和ESP&emsp;&emsp;80386的指针寄存器有基址寄存器EBP，堆栈指针寄存器ESP和指令指针寄存器EIP。 EBP寄存器：称为基址寄存器，可作为通用寄存器用于存放操作数，常用来代替堆栈指针访问堆栈中的数据。 ESP寄存器：称为堆栈指针寄存器，不可作为通用寄存器使用，ESP存放当前堆栈栈顶的地址，一般情况下，ESP和EBP联合使用来访问函数中的参数的局部变量。 EIP寄存器：称为指令指针寄存器，总是指向下一跳要执行的指令的地址，一般情况下无需修改EIP。 &emsp;&emsp;ESP和EBP常配合使用完成堆栈的访问。 标志寄存器EFLAGS&emsp;&emsp;标志寄存器EFLAGS一共有32位，在这32位中大部分是保留给编写操作系统的人用的，一般情况下只需知道32位的低16位中的8位即可。 OF（Overflow Flag）：溢出标志，溢出时为1，否则置0. DF（Direction Flag）：方向标志，在串处理指令中控制信息的方向。 IF（Interrupt Flag）：中断标志。 AF（Auxiliary carry Flag）：辅助进位标志，有进位时置1，否则置0。 ZF（Zero Flag）：零标志，运算结构为0时ZF位置1，否则置0。 SF（Sign Flag）：符号标志，结果为负数置1，否则置0。 CF（Carry Flag）：进位标志，进位时置1，都在置0。 PF（Parity Flag）：奇偶标志，结果操作数中1的个数为偶数时置1，否则置0。 &emsp;&emsp;EFLAGS是实现条件判断和逻辑判断的一种机制，在汇编语言中一般不直接访问EFLAGS寄存器，而是通过指令的操作隐含访问EFLAGS寄存器。 寻址方式及作用 立即寻址，通常用于赋值。 示例：mov eax，56h 直接寻址，通常用于处理变量。 示例：mov eax,[78h] . 寄存器寻址，操作数直接包含在寄存器中。 示例：mov eax,ebx 寄存器间接寻址，操作数的有效地址在寄存器中，而操作数在存储器中。 示例：mov eax,[edi] 寄存器相对寻址，常用于访问数组。 示例：mov eax,[edi+32h] 基址加变址寻址，常用于访问数组。 示例：mov eax,[ebp+esi] 相对基址加变址寻址 示例：mov eax,[ebx+edi-10h]]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge:二进制炸弹05]]></title>
    <url>%2F2019%2F04%2F16%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B905%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;逐渐进入白热化、、、 phase_5汇编代码与解析1234567891011121314151617181920212223242526272829303132333408048d5b &lt;phase_5&gt;: 8048d5b: 83 ec 2c sub $0x2c,%esp 8048d5e: 8d 44 24 1c lea 0x1c(%esp),%eax 8048d62: 89 44 24 0c mov %eax,0xc(%esp) 8048d66: 8d 44 24 18 lea 0x18(%esp),%eax 8048d6a: 89 44 24 08 mov %eax,0x8(%esp) 8048d6e: c7 44 24 04 0f a3 04 movl $0x804a30f,0x4(%esp) //输入格式为两个整数 8048d75: 08 8048d76: 8b 44 24 30 mov 0x30(%esp),%eax 8048d7a: 89 04 24 mov %eax,(%esp) 8048d7d: e8 de fa ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 8048d82: 83 f8 01 cmp $0x1,%eax //sscanf()返回值和1比较 8048d85: 7f 05 jg 8048d8c &lt;phase_5+0x31&gt; //%eax&gt;1 否则爆炸 输入大于一个数 应该是输两个 8048d87: e8 89 03 00 00 call 8049115 &lt;explode_bomb&gt; 8048d8c: 8b 44 24 18 mov 0x18(%esp),%eax //结合下面分析此处的0x18(%esp)应该为所求的第一个整数 8048d90: 83 e0 0f and $0xf,%eax //按位与 结合下面的判断 此时%eax！=15（二进制1111） 15以下的非负数和0xf想与还是本身 8048d93: 89 44 24 18 mov %eax,0x18(%esp) 8048d97: 83 f8 0f cmp $0xf,%eax 8048d9a: 74 2a je 8048dc6 &lt;phase_5+0x6b&gt; //%eax!=15 否则爆炸 8048d9c: b9 00 00 00 00 mov $0x0,%ecx //ecx=0 8048da1: ba 00 00 00 00 mov $0x0,%edx //edx=0 8048da6: 83 c2 01 add $0x1,%edx //edx=1 &lt;--跳回此地 执行edx++ 8048da9: 8b 04 85 c0 a1 04 08 mov 0x804a1c0(,%eax,4),%eax //从数组中取值 eax做数组下标取出的值赋给eax 8048db0: 01 c1 add %eax,%ecx //ecx=eax+ecx 8048db2: 83 f8 0f cmp $0xf,%eax //比较eax和15 8048db5: 75 ef jne 8048da6 &lt;phase_5+0x4b&gt; //eax不等于15就又跳回去了 最终eax要取到15--&gt; 8048db7: 89 44 24 18 mov %eax,0x18(%esp) 8048dbb: 83 fa 0f cmp $0xf,%edx //edx和15比 edx起始值为0 每次循环加1 所有循环了15次 8048dbe: 75 06 jne 8048dc6 &lt;phase_5+0x6b&gt; //edx不等于15就爆炸 所以要edx=15 8048dc0: 3b 4c 24 1c cmp 0x1c(%esp),%ecx //0x1c(%esp)应该是第二个整数 它等于ecx 8048dc4: 74 05 je 8048dcb &lt;phase_5+0x70&gt; //0x1c(%esp)==%ecx 8048dc6: e8 4a 03 00 00 call 8049115 &lt;explode_bomb&gt; 8048dcb: 83 c4 2c add $0x2c,%esp 8048dce: c3 ret phase_5拆除&emsp;&emsp;简单说一下上面的代码的思路，最关键的部分在循环阶段，输入的第一个整数eax作为数组下标，每次循环取出下标对应的数组元素值赋给该整数eax，这个eax初始值不等于15但是经过15次循环后最终取值取到15，第二个整数的值等于数组从下标1-15对应的元素之和。这个题很关键的一点在确定数组的元素值，然后根据最后的数值逆推15次循环之前的初试数值。一开始尝试一个一个地址的查看数组元素：太慢太耗费时间，然后又发现了新的查看数组元素的方法p *数组首地址(可以是数组名)@数组长度 尝试了下：通过上图数据数组下标可以从0取到15，其实通过汇编代码也可以确定，因为最终循环结束是起标志作用的edx等15时。根据数组元素与代码逻辑，逐一逆推： edx eax 数值 1 5 12 2 12 3 3 3 7 4 7 11 5 11 13 6 13 9 7 9 4 8 4 8 9 8 0 10 0 10 11 10 1 12 1 2 13 2 14 14 14 6 15 6 15 经过分析可以发现，第一个整数的值是5，第二个整数的值是第三列所有数的和115。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge:二进制炸弹04]]></title>
    <url>%2F2019%2F04%2F15%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B904%2F</url>
    <content type="text"><![CDATA[pahse_4汇编代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666708048c95 &lt;func4&gt;: 8048c95: 56 push %esi 8048c96: 53 push %ebx 8048c97: 83 ec 14 sub $0x14,%esp 8048c9a: 8b 54 24 20 mov 0x20(%esp),%edx 8048c9e: 8b 44 24 24 mov 0x24(%esp),%eax 8048ca2: 8b 74 24 28 mov 0x28(%esp),%esi 8048ca6: 89 f1 mov %esi,%ecx 8048ca8: 29 c1 sub %eax,%ecx 8048caa: 89 cb mov %ecx,%ebx 8048cac: c1 eb 1f shr $0x1f,%ebx //逻辑右移指令，功能是将操作数右移，原最低位移入进位标志CF，原最高位补0；可用于无符号数除法 8048caf: 01 d9 add %ebx,%ecx 8048cb1: d1 f9 sar %ecx //算术右移指令，功能是将操作数右移，符号位保持不变，可用于有符号数除法 8048cb3: 8d 1c 01 lea (%ecx,%eax,1),%ebx 8048cb6: 39 d3 cmp %edx,%ebx 8048cb8: 7e 17 jle 8048cd1 &lt;func4+0x3c&gt; //小于等于则跳转 必须满足才可以 8048cba: 8d 4b ff lea -0x1(%ebx),%ecx 8048cbd: 89 4c 24 08 mov %ecx,0x8(%esp) 8048cc1: 89 44 24 04 mov %eax,0x4(%esp) 8048cc5: 89 14 24 mov %edx,(%esp) 8048cc8: e8 c8 ff ff ff call 8048c95 &lt;func4&gt; //递归调用 8048ccd: 01 d8 add %ebx,%eax 8048ccf: eb 1b jmp 8048cec &lt;func4+0x57&gt; //跳出结束 不会执行这步 8048cd1: 89 d8 mov %ebx,%eax 8048cd3: 39 d3 cmp %edx,%ebx 8048cd5: 7d 15 jge 8048cec &lt;func4+0x57&gt; //大于等于则跳转 跳出结束 要结束需要同时满足： 8048cd7: 89 74 24 08 mov %esi,0x8(%esp) //8048cb8: 7e 17 jle 8048cd1 &lt;func4+0x3c&gt; 8048cdb: 8d 43 01 lea 0x1(%ebx),%eax //8048cd5: 7d 15 jge 8048cec &lt;func4+0x57&gt; 8048cde: 89 44 24 04 mov %eax,0x4(%esp) 8048ce2: 89 14 24 mov %edx,(%esp) 8048ce5: e8 ab ff ff ff call 8048c95 &lt;func4&gt; 8048cea: 01 d8 add %ebx,%eax 8048cec: 83 c4 14 add $0x14,%esp 8048cef: 5b pop %ebx 8048cf0: 5e pop %esi 8048cf1: c3 ret 08048cf2 &lt;phase_4&gt;: 8048cf2: 83 ec 2c sub $0x2c,%esp 8048cf5: 8d 44 24 1c lea 0x1c(%esp),%eax 8048cf9: 89 44 24 0c mov %eax,0xc(%esp) 8048cfd: 8d 44 24 18 lea 0x18(%esp),%eax 8048d01: 89 44 24 08 mov %eax,0x8(%esp) 8048d05: c7 44 24 04 0f a3 04 movl $0x804a30f,0x4(%esp) //(gdb) x/sb 0x804a30f =&gt; 0x804a30f: &quot;%d %d&quot; 8048d0c: 08 8048d0d: 8b 44 24 30 mov 0x30(%esp),%eax 8048d11: 89 04 24 mov %eax,(%esp) 8048d14: e8 47 fb ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 8048d19: 83 f8 02 cmp $0x2,%eax //和2比较 8048d1c: 75 07 jne 8048d25 &lt;phase_4+0x33&gt; //不等于就爆炸 必须输入两个整数 8048d1e: 83 7c 24 18 0e cmpl $0xe,0x18(%esp) //14和0x18(%esp)比较 8048d23: 76 05 jbe 8048d2a &lt;phase_4+0x38&gt; //小于等于时跳转 0x18(%esp)&lt;=14 8048d25: e8 eb 03 00 00 call 8049115 &lt;explode_bomb&gt; 8048d2a: c7 44 24 08 0e 00 00 movl $0xe,0x8(%esp) //0x8(%esp)=14 8048d31: 00 8048d32: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) //0x4(%esp)=0 8048d39: 00 8048d3a: 8b 44 24 18 mov 0x18(%esp),%eax 8048d3e: 89 04 24 mov %eax,(%esp) 8048d41: e8 4f ff ff ff call 8048c95 &lt;func4&gt; //调函数 8048d46: 83 f8 0d cmp $0xd,%eax //返回值%eax和13比 8048d49: 75 07 jne 8048d52 &lt;phase_4+0x60&gt; //不相等就爆炸 返回值%eax=13 8048d4b: 83 7c 24 1c 0d cmpl $0xd,0x1c(%esp) 8048d50: 74 05 je 8048d57 &lt;phase_4+0x65&gt; //相等结束 0x1c(%esp)=13 猜测两个整数为0x18(%esp)和0x1c(%esp) 8048d52: e8 be 03 00 00 call 8049115 &lt;explode_bomb&gt; 8048d57: 83 c4 2c add $0x2c,%esp 8048d5a: c3 ret phase_4汇编指令 指令 注释 shr 逻辑右移指令，功能是将操作数右移，原最低位移入进位标志CF，原最高位补0；可用于无符号数除法 sar 算术右移指令，功能是将操作数右移，符号位保持不变，可用于有符号数除法 jle 小于等于则跳转 jge 大于等于则跳转 jbe 小于等于时跳转 jne 不相等时跳转 je 相等时跳转 phase_4拆除&emsp;&emsp;思路和分析，在代码中做了注释，捋下来就ok了。phase_4中函数部分和phase_3中有相似之处，要求必须输入两个整数，所以通关秘钥就是正确的两个整数了，通过分析，递归调用发生在func4函数中，这个函数有三个参数，一个返回值，没有经验积累具体的细节不好理解，但这不影响找出想要的结果。在phase_4函数中已经指定了两个数中的第二个数是13，也给出了另一个数的范围是小于等于14，试着类似于暴力破解的样子，尝试了下，发现2和13这两个整数可以成功拆除炸弹。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge:二进制炸弹03]]></title>
    <url>%2F2019%2F04%2F14%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B903%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;继续拆、、、 phase_3汇编代码123456789101112131415161718192021222324252627282930313233343536373839404108048c01 &lt;phase_3&gt;: 8048c01: 83 ec 2c sub $0x2c,%esp 8048c04: 8d 44 24 1c lea 0x1c(%esp),%eax 8048c08: 89 44 24 0c mov %eax,0xc(%esp) 8048c0c: 8d 44 24 18 lea 0x18(%esp),%eax 8048c10: 89 44 24 08 mov %eax,0x8(%esp) 8048c14: c7 44 24 04 0f a3 04 movl $0x804a30f,0x4(%esp) //(gdb) x/sb 0x804a30f =&gt; 0x804a30f: &quot;%d %d&quot; 8048c1b: 08 8048c1c: 8b 44 24 30 mov 0x30(%esp),%eax 8048c20: 89 04 24 mov %eax,(%esp) 8048c23: e8 38 fc ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 8048c28: 83 f8 01 cmp $0x1,%eax //%eax和1比较 8048c2b: 7f 05 jg 8048c32 &lt;phase_3+0x31&gt; //大于1就跳转 否则爆炸 8048c2d: e8 e3 04 00 00 call 8049115 &lt;explode_bomb&gt; 8048c32: 83 7c 24 18 07 cmpl $0x7,0x18(%esp) //0x18(%esp)和7比较 8048c37: 77 3c ja 8048c75 &lt;phase_3+0x74&gt; //大于7则跳转至爆炸 所以不能大于7 8048c39: 8b 44 24 18 mov 0x18(%esp),%eax 8048c3d: ff 24 85 a0 a1 04 08 jmp *0x804a1a0(,%eax,4) 8048c44: b8 5c 03 00 00 mov $0x35c,%eax //gdb p/x *0x804a1a0 8048c49: eb 3b jmp 8048c86 &lt;phase_3+0x85&gt; 8048c4b: b8 49 01 00 00 mov $0x149,%eax 8048c50: eb 34 jmp 8048c86 &lt;phase_3+0x85&gt; 8048c52: b8 4c 02 00 00 mov $0x24c,%eax 8048c57: eb 2d jmp 8048c86 &lt;phase_3+0x85&gt; 8048c59: b8 ee 00 00 00 mov $0xee,%eax 8048c5e: eb 26 jmp 8048c86 &lt;phase_3+0x85&gt; 8048c60: b8 20 03 00 00 mov $0x320,%eax 8048c65: eb 1f jmp 8048c86 &lt;phase_3+0x85&gt; 8048c67: b8 96 00 00 00 mov $0x96,%eax 8048c6c: eb 18 jmp 8048c86 &lt;phase_3+0x85&gt; 8048c6e: b8 42 03 00 00 mov $0x342,%eax 8048c73: eb 11 jmp 8048c86 &lt;phase_3+0x85&gt; 8048c75: e8 9b 04 00 00 call 8049115 &lt;explode_bomb&gt; 8048c7a: b8 00 00 00 00 mov $0x0,%eax 8048c7f: eb 05 jmp 8048c86 &lt;phase_3+0x85&gt; 8048c81: b8 1d 02 00 00 mov $0x21d,%eax 8048c86: 3b 44 24 1c cmp 0x1c(%esp),%eax //都往这里跳 出口条件判定 8048c8a: 74 05 je 8048c91 &lt;phase_3+0x90&gt; //0x1c(%esp),%eax相等就可以结束了 8048c8c: e8 84 04 00 00 call 8049115 &lt;explode_bomb&gt; 8048c91: 83 c4 2c add $0x2c,%esp 8048c94: c3 ret phase_3汇编指令 指令 注释 lea 计算源操作数内存地址放进目的数 jg 有符号数大于则跳转 ja 无符号大于则跳转 je 等于则跳转 phase_3拆除&emsp;&emsp;使用查看内存命令，查看0x804a30f需要输入两个整数，sscanf()函数如果执行成功返回值是参数个数，否则返回EOF，有代码知返回参数大于1，所以解除炸弹的字符串应该是两个整数。0x18(%esp)不能大于7，查看*0x804a1a0：所以如果0x18(%esp)小于等于7则跳转到8048c44+4*%eax，0x18(%esp)是第一个整数，0x1c(%esp)是第二个整数，这是一个switch分支结构，第一个数的不同，会导致第二个数也不相同，结果应该有8组，第一个数取0-7，第二个数按跳转规则计算即可。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge:二进制炸弹02]]></title>
    <url>%2F2019%2F04%2F14%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B902%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;继续拆炸弹、、、昨天晚上又加班看了看汇编的指令集，对汇编语言有了个大概的了解，今天继续攻克试试。 phase_2汇编代码123456789101112131415161718192021222324252608048bb4 &lt;phase_2&gt;: 8048bb4: 53 push %ebx 8048bb5: 83 ec 38 sub $0x38,%esp 8048bb8: 8d 44 24 18 lea 0x18(%esp),%eax 8048bbc: 89 44 24 04 mov %eax,0x4(%esp) 8048bc0: 8b 44 24 40 mov 0x40(%esp),%eax 8048bc4: 89 04 24 mov %eax,(%esp) 8048bc7: e8 70 05 00 00 call 804913c&lt;read_six_numbers&gt; //读入6个数 8048bcc: 83 7c 24 18 00 cmpl $0x0,0x18(%esp) 8048bd1: 79 22 jns 8048bf5 &lt;phase_2+0x41&gt; //0x18(%esp)不是负数 8048bd3: e8 3d 05 00 00 call 8049115 &lt;explode_bomb&gt; 8048bd8: eb 1b jmp 8048bf5 &lt;phase_2+0x41&gt; 8048bda: 89 d8 mov %ebx,%eax //这应该是进入循环的点 8048bdc: 03 44 9c 14 add 0x14(%esp,%ebx,4),%eax //求%esp+4*%ebx+0x14中的值与%eax中值的和 放入%eax 8048be0: 39 44 9c 18 cmp %eax,0x18(%esp,%ebx,4) //%eax与%esp+4*%ebx+0x18比较 注意0x14(%esp,%ebx,4)与0x18(%esp,%ebx,4)相差4个字节 应该是相邻的整数 8048be4: 74 05 je 8048beb &lt;phase_2+0x37&gt; //要想不爆炸 必须相等才行 8048be6: e8 2a 05 00 00 call 8049115 &lt;explode_bomb&gt; 8048beb: 83 c3 01 add $0x1,%ebx //%ebx值加一 8048bee: 83 fb 06 cmp $0x6,%ebx //为6跳则出循环 猜想循环和6个数有关 8048bf1: 75 e7 jne 8048bda &lt;phase_2+0x26&gt; 8048bf3: eb 07 jmp 8048bfc &lt;phase_2+0x48&gt; 8048bf5: bb 01 00 00 00 mov $0x1,%ebx //非负数时跳转到这 %ebx赋值1 8048bfa: eb de jmp 8048bda &lt;phase_2+0x26&gt; 8048bfc: 83 c4 38 add $0x38,%esp 8048bff: 5b pop %ebx 8048c00: c3 ret phase_2汇编指令&emsp;&emsp;在phase_1整理过得这里不再列出，等做完再系统性的整理一下。 指令 注释 push 把字压入堆栈 lea 装入有效地址 cmp 比较，两操作数做减法运算 jns 符号位为“0”时转移，即不是负数时跳转 jmp 无条件转移 jne 不等于时转移 pop 把字弹出堆栈 phase_2拆除&emsp;&emsp;任务书中提到，phase2是关于循环，重点看一看地址跳转的部分，特别是往后调走循环和跳出循环的指令，确定循环内执行的操作。经分析，若要不引爆炸弹，其循环方式与顺序应与下图一致（画的有点烂）：所以需要使上述循环条件都成立，细细的分析一下循环部分的内容，因为我对汇编不熟悉，所以里面有些东西困扰了我好久，翻看了不少资料，趁现在来灵感了，抓紧记一下。以下分析按照不引爆炸弹的情况进行： 0x18(%esp)与0比较 %ebx赋值为1 %eax=%ebx %eax=%esp+4*%ebx+0x14+%eax，因为%ebx=1，所以相当于%eax=0x18(%esp)+%eax %eax与%esp+4*%ebx+0x18比较，因为%ebx=1，所以相当于%eax与0x1c(%esp)比较 %ebx++，此时%ebx=2小于6，继续循环。 接下来的事情就和上面第二步往下类似了，就是%ebx和%eax在逐次加一，这也就出现了0x18(%esp)、0x1c(%esp)、0x20(%esp)···像极了遍历数组时的场景（应该就是吧~），%ebx为循环条件。 &emsp;&emsp;综上，这6个数要满足，第一个数是非负数，第n个数加n等于第n+1个数的值。 尝试写代码还原了一下：12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; int a[]= &#123;-1,0,1,3,6,10,15&#125;;//下标从1开始 忽略0处数值 int eax,ebx; int flag=0; if(a[1]&lt;0) flag=1;//此处应当执行爆炸函数 else &#123; ebx=1; do &#123; eax=ebx; eax=eax+a[ebx]; if(eax==a[ebx+1]) ebx++; else flag=1; &#125; while(ebx&lt;6); &#125; if(flag) cout&lt;&lt;"bomb..."&lt;&lt;endl; else cout&lt;&lt;"success"&lt;&lt;endl; return 0;&#125; 将0 1 3 6 10 15 输入进去，结果正确。答案不唯一，只要符合规则就可以。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201号challenge:二进制炸弹01]]></title>
    <url>%2F2019%2F04%2F13%2F201%E5%8F%B7challenge-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B901%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;进入第二阶段测试，逆向拆除“二进制炸弹”程序，考察对程序机器级表示、汇编语言、调试器和逆向工程等的理解，拆除过程需要在Linux下进行。 &emsp;&emsp;看了看固态空闲的容量，能装的下个虚拟机，于是开始着手下载安装虚拟机和kali。装了两遍，第一遍装系统的时候黑屏提示end kernel panic not syncing:attempted to kill init，搜寻了很多解决办法，看着成功率都不是很高，有一条简单好实现的就是换个版本高点的VMware尝试，于是卸载干净之前的VMware10又下载的VMware Workstation Pro14版本，跟着教程一步一步成功安装。 &emsp;&emsp;装好kali之后发现无法进行汉语的输入，而且不能将本地的文件拷贝到虚拟机中，这就很难，于是又解决这两个问题。跟着各种帖子都试了试，发现这个安装中文输入就是搞不定，倒腾了好久后发现是我的新系统中没有数据源，加入了一个阿里的数据这才搞定。之后安装了一个VMware Tools实现了从本地拖拽文件到虚拟机的功能，全部搞定用了一上午的时间。 &emsp;&emsp;基础环境搭建好，迫不及待尝试一下，在解题之前，预先查看了提供的主函数文件bomb.c，只是列出了大体的框架，并不能提供具体的解题信息，单单从函数中看，有6个阶段，每个阶段都需要输入一个字符串，若符规则，就能拆除炸弹进入下一环节。那就从phase1开始吧，正好第一阶段有提示，所以跟着第一阶段的提示走一走，找找感觉… phase_1汇编代码&emsp;&emsp;使用终端先切到bomb所在目录下，键入指令objdump -d bomb &gt; asm.txt ，使用objdump将bomb的汇编代码写入到asm.txt中。找到phase_1的汇编代码，如下：12345678910111208048b90 &lt;phase_1&gt;: 8048b90: 83 ec 1c sub $0x1c,%esp 8048b93: c7 44 24 04 44 a1 04 movl $0x804a144,0x4(%esp) 8048b9a: 08 8048b9b: 8b 44 24 20 mov 0x20(%esp),%eax 8048b9f: 89 04 24 mov %eax,(%esp) 8048ba2: e8 63 04 00 00 call 804900a &lt;strings_not_equal&gt; 8048ba7: 85 c0 test %eax,%eax 8048ba9: 74 05 je 8048bb0 &lt;phase_1+0x20&gt; 8048bab: e8 65 05 00 00 call 8049115 &lt;explode_bomb&gt; 8048bb0: 83 c4 1c add $0x1c,%esp 8048bb3: c3 ret phase_1汇编指令&emsp;&emsp;上面用到的汇编指令功能简述： 指令 注释 sub 减法运算 mov 传送字或字节 movl 传送32位的长字值（w：16位，b：8位） call 过程调用 test 测试，两操作数做与运算 je 等于时转移 add 加法运算 ret 过程返回 phase_1拆除&emsp;&emsp;通过分析得到，将0x804a144中的数据赋值给*(esp+4)，输入的字符串赋值到%eax中，调用字符串比较函数，如果相等就进入下一阶段，不相等就调用引爆函数&lt;explode_bomb&gt;。所以要想解除本关炸弹，输入的字符串需要和0x804a144中存放的字符串相等。查看0x804a144中的内容，得到：运行bomb输入图中的字符串，成功通过第一阶段。 PS：即使有例子指引，顺下来还是很不愉快，要再仔细研究研究。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RapidTyping]]></title>
    <url>%2F2019%2F04%2F12%2FRapidTyping%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;虽然解出来了这道题，但是我不确定我是否get到了它的点，能力有限，所想到的方法也有限，先记录一下我的解题方法。 前奏灵感&emsp;&emsp;题目要求2.5秒内正确输入图片中的验证码（有40个字符），和前面刚做的Calculator极其相似，立马就想到了用爬虫来解决。 可行性&emsp;&emsp;为了验证能否使用爬虫抓取有用信息，直接查看网页源码，果不其然，图片以加密字符串的形式展示出来，有base64字样。&emsp;&emsp;尝试进行base64解密，成功解密，解密后的图片源码中含有图片中的验证码。 继续思考&emsp;&emsp;使用爬虫可以获取加密后的图片的编码，可是解码后对我才有用，如何解码呢，有不少在线的base64加密解密网站，然后经过查阅，本地解码也是可行的，这就了然了。爬虫获取加密字符串，编写代码实现解密，处理解密后的字符串获取验证码。但是经过比对，图片中的验证码字符顺序与解密后字符串中的验证码字符顺序是不一样的，根据经验，验证码字符是按照x轴由小到大排序的，在解析字符串的时候，还需要将x的属性值取出来，便于对验证码字符进行排序。这么想来，这道题更像是在考验编程思维的功底。 解题&emsp;&emsp;首先在类中声明一个httpclient变量，这样类中所有请求都相当于一个浏览器中发出的。12static HttpClient hClient=new DefaultHttpClient();static HttpGet hget; 获取加密图片&emsp;&emsp;使用httpclient向题目页面地址发出请求，获取页面源码，使用EntityUtils工具类把网页实体转化为字符串，用jsoup解析网页，使用元素选择器获取图片标签中的内容，然后对字符串进行处理（去掉开头和结尾无用字符），得到加密后的图片编码。12345678910111213public static String crawSrc() throws IOException &#123; hget=new HttpGet("http://123.207.149.64:23331/captcha/");//设定题目页面地址 HttpResponse response=hClient.execute(hget);//发出请求 获取页面源码 String content=EntityUtils.toString(response.getEntity(),"utf-8");//网页实体转为字符串 Document doc = Jsoup.parse(content);//解析 Elements select = doc.select("[src]");//选择图片标签 //System.out.println(select);//输出为&lt;img ...&gt; String src=select.toString(); int index=src.indexOf(","); src=src.substring(index+1,src.length()-4); //System.out.println(src);//输出经加密的图片编码 return src;&#125; 进行解码&emsp;&emsp;Base64直接依赖于JDK，不要引入第三方jar包即可实现解码。通过反射来调用Base64的解密方法。12345678public static String base64Decode(String input) &#123; byte[] result=null; Class clazz=Class.forName("com.sun.org.apache.xerces.internal.impl.dv.util.Base64");//反射入口 Method method=clazz.getMethod("decode", String.class);//拿到解密方法decode result=(byte[]) method.invoke(null, input);//调用解密方法 String s=new String(result); return s;&#125; 获取验证码&emsp;&emsp;成功解码后，获得xml内容，进行分析来获取验证码。解密后是以字符串的形式存储的，jsoup可以对字符串进行解析，先取出每个text标签中的验证码字符，然后对字符以引号(“)为标志进行分割，存入字符串数组中，x轴属性值所在位置是有规律的，数组下标为1,7,13….，这样可以取出每个验证码字符所对应的x轴上的位置（自左向右）。因为字符串中的验证码字符是无序排列，而要匹配图片的验证码是需要从左向右依次对应的，所以要将字符串中取出的验证码字符，按照其在x轴上的位置进行排列才可以。这里采用简单的一个方法，图片的分辨率是固定的，为46050，其宽度为460像素，可以开辟一个长度为461的字符数组，值存放验证码字符，下标为该字符对应的x轴位置，不需要排序，按下标从小到大输出即可。1234567891011121314151617181920public static String process(Elements select) &#123; String s=select.toString();//select为所有取出的text标签 char[] st=select.text().toCharArray();//select.text()用于取出文本内容 即各验证码字符 String[] tempArr=s.split("\""); char[] code=new char[461];//将x轴位置与验证码字符一一对应 for(int i=0;i&lt;461;i++)//初始化 code[i]='*'; int j=0; for(int i=1;i&lt;=235;i=i+6) &#123; int index=Integer.parseInt(tempArr[i]);//x属性值做下标 code[index]=st[j];//该下标对应的验证码字符 j=j+2; &#125; String ans="";//存放验证码 for(int i=0;i&lt;461;i++) if(code[i]!='*') ans=ans+code[i];//将各验证码字符拼接到一起组成验证码 System.out.println(ans); return ans;&#125; 提交&emsp;&emsp;得到验证码后，拼接到提交页面的地址之后，进行提交，并获取服务器的返回页面，得到flag。12345678public static void submit(String ans) throws IOException &#123; String url="http://123.207.149.64:23331/captcha/?code="; url=url+ans;//将验证码拼接到url之后 hget=new HttpGet(url); HttpResponse response=hClient.execute(hget);//获取服务器返回页面 String content=EntityUtils.toString(response.getEntity(),"utf-8");//将网页转为字符串类型 System.out.println(content);&#125; &emsp;&emsp;将取得的页面源码，保存为html格式，效果如下：&emsp;&emsp;另将主函数贴出：1234567891011public static void main(String[] args) throws IOException &#123; String src=crawSrc();//获取经base64加密后的图片 src=base64Decode(src); System.out.println("解密后："+src); Document doc = Jsoup.parse(src); Elements select = doc.select("text"); //System.out.println(select.text());//长度79 //System.out.println(select); String ans=process(select); submit(ans);&#125; &emsp;&emsp;整个代码中进行过多次中间变量的输出，正是因为研究比较这些输出，才得以完成此次解题。如需详细理解各步骤，最好按顺序一步一步执行下，这里只记载了解题的大概过程，细节方面照顾不到，见谅。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calculator]]></title>
    <url>%2F2019%2F04%2F11%2FCalculator%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最开始，看到题，1.5s内计算出结果并提交，人工计算几乎是不可能的（对我来讲），还以为有其他蹊跷方法不需要算出结果就能获得flag，没想到真的是提交结果后给出flag。 网络爬虫&emsp;&emsp;抱着试试看的态度，打算计算出结果提交一下试试，题中给的建议是使用Python request库，奈何我没有学过Python，现在学也不是立马就能拿来用的，不如先用java试试吧。 &emsp;&emsp;要想使用计算机直接计算结果并提交，需要获知运算表达式，并解析表达式，使计算机能够计算出结果，然后提交给服务器，并获取服务器的返回信息，因为flag很可能就在返回信息中。题中给出的思考：服务器怎么知道获得算式的和提交答案的是一个人？经过试验，只要获取表达式和提交结果是在同一个浏览器中进行（没有清除过缓存，本地的cookie和服务器端的session通过sessionId对应）就可以，而网络爬虫可以很好的满足以上条件（网络爬虫就是模拟一个浏览器向服务器发出请求并接收返回信息），正好对爬虫有一丁点儿了解，就拿来用用了。 解题过程&emsp;&emsp;先把解题用的代码列出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Calculator &#123; public static void main(String[] args) throws Exception &#123; HttpClient hc=new DefaultHttpClient(); HttpGet hg=new HttpGet("http://123.207.149.64:23331/calculator/");//表达式页面 HttpResponse response=hc.execute(hg); String content=EntityUtils.toString(response.getEntity(),"utf-8"); //System.out.println(content);//输出网页源码 Document doc = Jsoup.parse(content); Elements select = doc.select("form span");//取出表达式 String exp=select.text(); System.out.println(exp);//输出算术表达式 //将字符串分解，转化为四个整数型数据 int a[]= &#123;0,0,0,0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int index = exp.indexOf(" "); a[i] = Integer.parseInt(exp.substring(0, index)); if (i != 3) exp = exp.substring(index + 3); &#125; String res=Res(a);//调用求值函数 String url="http://123.207.149.64:23331/calculator/?answer="+res;//将结果拼接到ip地址 提交给服务器 //System.out.println(url); hg=new HttpGet(url); response=hc.execute(hg); content=EntityUtils.toString(response.getEntity(),"utf-8"); System.out.println(content);//输出含义flag的网页源码 &#125; public static String Res(int a[]) throws Exception &#123; HttpClient hc=new DefaultHttpClient(); //将表达式中的数字 拼接到url中 使用搜狗来获取结果 String url="https://www.sogou.com/web?query="+a[0]+"+%2B+"+a[1]+"+*+"+a[2]+"+-+"+a[3]+"+%3D&amp;_asf=www.sogou.com&amp;_ast=&amp;w=01019900&amp;p=40040100&amp;ie=utf8&amp;from=index-nologin&amp;s_from=index&amp;sut=1447&amp;sst0=1554691893839&amp;lkt=0%2C0%2C0&amp;sugsuv=00081C1D700880375CA00C16F9B87217&amp;sugtime=1554691893839"; System.out.println(url); HttpGet hg=new HttpGet(url); HttpResponse response=hc.execute(hg); String content=EntityUtils.toString(response.getEntity(),"utf-8"); Document doc = Jsoup.parse(content); Elements select = doc.select("div.calcresult"); String res=select.text(); res=res.replaceAll(" ", ""); System.out.println(res); int beginIndex=res.lastIndexOf("="); res=res.substring(beginIndex+2); System.out.println(res); return res; //返回最终结果 &#125;&#125; &emsp;&emsp;步骤简要概括： 使用爬虫将表达式爬取 处理表达式，经多次测试，发现每次运算都是四个整数，且运算符是固定的，只需分离出数字即可。 尝试使用java直接计算结果，数字太大，无法计算得到正确结果。 发现可以直接搜索表达式来得到结果，百度，搜狗都可以 最开始使用百度，通过拼接ip地址，达到实现计算表达式的目的，但是百度有反爬虫措施，无法爬取结果。 而后使用搜狗，原理一样，可以爬取结果。 经过分析，发现提交给服务器的页面，其通过在ip地址后拼接结果来传值，于是将结果拼接到ip后提交。 获取服务器的返回页面源码。 将源码保存为html文件得到如下页面，得到flag。 PS:这么做走了弯路，在提交结果前，两次使用爬虫获取页面内容（第一次获取表达式，第二次获取运算结果），通过爬虫获取计算结果是比较耗费时间的（相当于那1.5s来说），所以我试了三次才提交成功，前两次都是用时1.6s多，返回超时页面，第三次运气好，1.3s搞定，成功获取flag。 简要完善&emsp;&emsp;上面提到，多次使用爬虫并不能每次都可以成功提交，且失败几率较大，因为在获取运算结果上耗费了不少时间，后来想到，可以使用大整数运算来计算结果。 1234567891011121314public static BigInteger Operation(String exp) &#123; int index = exp.indexOf(" "); BigInteger n1=new BigInteger(exp.substring(0, index)); exp = exp.substring(index + 3); index = exp.indexOf(" "); BigInteger n2=new BigInteger(exp.substring(0, index)); exp = exp.substring(index + 3); index = exp.indexOf(" "); BigInteger n3=new BigInteger(exp.substring(0, index)); exp = exp.substring(index + 3); index = exp.indexOf(" "); BigInteger n4=new BigInteger(exp.substring(0, index)); return n2.multiply(n3).add(n1).subtract(n4);//n2*n3+n1-n4&#125; &emsp;&emsp;经测试，使用大整数运算的方法来处理，要快不少，每次都可以成功提交。将此方法放到字符串分解之前，注释掉使用爬虫方法获取结果的语句即可。另外，表达式获取和结果提交，要使用同一个HttpClient来执行，这样才可以识别成同一人，换了HttpClient提交会提示：Expression has not been generated.]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫简单上手]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;看了一下web的题，可能需要用到爬虫，所以简单了解一下网络爬虫，静态网页的爬虫，实现一些简单的小功能还是很实用的，也为后面解题做准备。 关于爬虫&emsp;&emsp;这里不讲各种百科上的官方定义，简单说一说自己的理解。 &emsp;&emsp;真正的网络爬虫可以称为信息采集器，它可以按照一定的规则自动的在互联网上抓取信息，我目前所实现的爬虫，只是简单的抓取某一特定网页的自己想要的信息。网络爬虫可以分为全网漫爬型和垂直型，前者是指爬取数据范围广，在整个互联网内获取数据，像谷歌百度之类。后者是指针对某一网站或某一类型数据的抓取，比如专门爬取微博信息的爬虫等。 &emsp;&emsp;爬虫就是取代浏览器，向网络上的服务器发送请求，并获取服务器中的资源来取得我们想要的信息。随便一搜爬虫的实现，Python的教程居多，但是java也可以简单上手。 上手准备工具： Eclipse、httpclient和jsoup的相应jar包 HttpClient简介： HttpClient是apache组织下面的一个用于处理HTTP请求和响应的开源工具。它不是一个浏览器，而是一个类库。它在JDK的基本类库基础上做了更好的封装。 HttpClient抓取网页流程： 创建HttpClient对象。 创建请求方法的实例，并制定请求URL。如果需要发送GET请求，创建HTTPGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams（HttpParams params）方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity（HttpEntity entity）方法来设置请求参数。 Jsoup简介： jsoup是一款javaHTML解析器，可以直接解析URL地址，HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 Jsoup处理网页流程： 从一个URL，文件或字符串中解析HTML。 使用DOM或CSS选择器来查找、取出数据。 可操作HTML元素、属性、文本。 &emsp;&emsp;通常在写爬虫程序时，httpclient集合jsoup共同使用即可实现不错的爬虫系统。httpclient负责模拟浏览器发送请求，jsoup负责解析httpclient请求返回的HTML页面，解析获取需要的数据。 简单上手&emsp;&emsp;写一个简单的英汉互译系统练手，一般在翻译网站上查询单词的意思时，是在网址后拼接待查询单词向服务器提交，例如爱词霸，查询hello的汉语意思时，地址栏显示的网址为：http://www.iciba.com/hello 利用这可特性，结合上面的基础知识可以实现简单的单词释义查询。下面将实现代码列出： 1234567891011121314151617181920public static void main(String[] args) throws IOException &#123; HttpClient hClient=new DefaultHttpClient(); //设置响应时间，设置传输源码时间，设置代理服务器（防止被识别ip加入黑名单而无法爬取） //百度 代理服务器ip 即可得到代理服务器 本例可不使用 /*hClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 10000) .setParameter(CoreConnectionPNames.SO_TIMEOUT, 10000) .setParameter(ConnRouteParams.DEFAULT_PROXY, new HttpHost("116.209.58.123",9999 )); */ //爬虫URL大部分是get请求，创建get请求对象 HttpGet hget=new HttpGet("http://www.iciba.com/hello"); //向传智播客网站发送请求 获取网页源码 HttpResponse response=hClient.execute(hget); //EntityUtils工具类把网页实体转换成字符串 String content=EntityUtils.toString(response.getEntity(),"utf-8"); //jsoup解析网页 Document doc = Jsoup.parse(content); //使用元素选择器选择网页内容li.lione a Elements select = doc.select("li.clearfix p"); System.out.println(select.text()); &#125; &emsp;&emsp;简单解析处理后的效果：]]></content>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Invisible_flag]]></title>
    <url>%2F2019%2F04%2F09%2FInvisible-flag%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;看不见的flag，应该是给隐藏起来了？ &emsp;&emsp;图片下载下来，下面明显少了些，而且题目中给出的提示：图片长度，查看属性，分辨率为564*400，高度比宽度要小。 &emsp;&emsp;下载010 Editor，打开图片，发现将鼠标放在不同数据区域，会有相应的提示。 &emsp;&emsp;找到宽度的数据区域，十六进制的0190正好是400像素，将0190改为0234即564像素，这样就成了长度和宽度一样的方形图片，保存后查看图片，flag出现。 &emsp;&emsp;关于PNG文件格式中IHDR的一点儿补充： IHDR 头文件数据块，它包含有PNG文件中存储的图像数据的基本信息，并作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。 89 50 4E 47 0D 0A 1A 0A为PNG文件署名域，用来标志该文件是PNG文件 00 00 02 34 width 图像宽度，以像素为单位 00 00 01 90 height 图像高度，以像素为单位]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2019%2F04%2F08%2FShell%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;又是分析数据包的题，本以为之前做过几个了，这个应该会比较容易解决，没想到还是费了好大劲儿。说到底还是理解不深入，这种类型的题，还需要多练呐，欠缺经验和积累。 &emsp;&emsp;打开数据包，扫了一遍，TCP协议居多，开头就是个广播寻找IP地址的，但是貌似和本题没有啥关系，然后三次握手，结尾四次挥手。没有发现NFS和频繁的HTTP协议，即没有进行文件交互，也没有进行html页面的传输。之前做这种流量分析题，有用的信息可能会出现在data属性中，好在数据包列表区中的内容不太多，一行一行的看下来也不难，于是一个一个点开看，中间发现了一些指令类的东西，然后在第68行，发现了可疑字符串。 &emsp;&emsp;后来发现，可以追踪的TCP流，这要比一个一个看好整多了… &emsp;&emsp;通过shell命令，进行了一系列操作，经查阅知，这一可疑字符串经base64加密，大小写字母转换（swapcase()）所得。所以先把字符串的字母大小写转换，然后经过base64解密得到flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Another 01Game]]></title>
    <url>%2F2019%2F04%2F07%2FAnother%2001Game%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这个题很有意思、、、但是如果题干给的提示不这么详细，那就不好玩了、、、 二维码&emsp;&emsp;二维码（Quick Response Code，QR Code），以下引用自百度百科。 &emsp;&emsp;二维码又称二维条码，常见的二维码为QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。&emsp;&emsp;二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。 &emsp;&emsp;二维码，是和二进制数0,1有密切关联的。 解题步骤&emsp;&emsp;题干中明确给出了，那一串数字有1369个0和1，是37的平方，可以构成边长为37个数字的正方形二维码（虽然题干中直接给出了结论，但是这种分析的思想一定要具备，好好学习）。然后通过扫描二维码又可以得到一串二进制01字符串，进行ASCII解码得出结果。 1）绘制二维码&emsp;&emsp;最初尝试利用C++在codeblock中打印输出二维码（因为之前写过黑白棋游戏，打印棋盘最开始的想法和这个类似，所以优先想到用代码打印图形的方式来绘制二维码），但是尝试了好几次，又是调背景色又是调字体大小又是换方块大小又是01互换，都没能扫出信息，应该是每行之间的行间隔太大，识别不成二维码。然后又打开eclipse进行尝试，成功得到可扫描的二维码（java是最好用的语言！！）。下面将处理代码贴出： 1234567891011public static void Qrcode() &#123; String s="00...0110";//此处为题中给出的二进制数字串，太长了，省略写 int f=0; for(int i=0;i&lt;s.length();i++) &#123; f++;//■ ■ █ ▇ ▉ ▉ █ 这是用来输出二维码的黑色的方块，从中试了试，挑了个能扫出来信息的 if(s.charAt(i)=='0') System.out.print("██");//█ else System.out.print(" "); if(f%37==0) System.out.println(); &#125; &#125; &emsp;&emsp;最开始得到二维码后，感觉能成，但是字符太大了，一个页面装不下，没法直接扫，将字体调小后成功得到二维码。 2)处理01字符串&emsp;&emsp;掏出手机，扫描二维码，得到一串01字符串，该字符串长度为189，可以被7整除，按照ASCII的编码方式进行转换。直接写个函数，打印输出，控制台得到flag，搞定。 1234567891011121314public static void flag() &#123; String s="1100...101" ;//这是扫描二维码得到的一串二进制数字串，也挺长的 System.out.println(s.length());//189 可以被7整除 ASCII int a[]= &#123;64,32,16,8,4,2,1&#125;; int len=0; while (len &lt; s.length()) &#123; int sum = 0; for (int i = 0; i &lt; 7; i++) &#123;//7位一组 if (s.charAt(len++) == '1') &#123; sum += a[i]; &#125; &#125; System.out.print((char) sum); &#125; 感悟&emsp;&emsp;一道题要涉及到很多方方面面的知识，还需要多积累多练习啊~从最开始看到题时的一无所知，无从下手，到现在写下这篇博客，攻克下一个难关还是有些小喜悦的，但是我的进度还是有点慢，加油加油。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Birthday]]></title>
    <url>%2F2019%2F04%2F06%2FBirthday%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用工具，暴力破解。 &emsp;&emsp;刚刚使用Advanced Zip Password Recovery解决了一道题，再看这道题，感觉没啥难度。 &emsp;&emsp;题目中给出了提示，可以暴力破解，仔细阅读题干，小明是90后，很重要，用他的生日8位数字作为密码，也很重要。在Advanced Zip Password Recovery中进行设置，选定带破解的文件路径，攻击类型选择暴力破解（有90后这个提示，暴力破解是完全可行的，且时间是完全可以接受的），范围中只选择所有数字，开始于1990年的第一天“19900101”结束于当前日期“20190405”（讲道理，按照常理的话，结束日期最晚是出题日期，无所谓了），然后开始破解，19ms得出口令，输入口令解压，得到flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PkCrack]]></title>
    <url>%2F2019%2F04%2F05%2FPkCrack%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;好像涉及密码学中的某些知识，又是新探索。 密码学中的攻击模式&emsp;&emsp;明文（Plaintext），在密码学中是指传送方想要接受方获得的可读信息。明文经过加密所产生的信息被称为密文，而密文经过解密而还原得来得信息被称为明文。 &emsp;&emsp;密文（ciphertext或cyphertext），由明文经过加密算法所产生的。因为密文是一种除非使用恰当的算法进行解密，人类或计算机不可以直接阅读理解的明文的形态，所以可以被理解为加密的信息。解密与加密是相对的，即一种使使密文转化为明文的过程。 &emsp;&emsp;由上得出理解，明文就是能看得见的可读的信息，密文就是加密后不想被不知道密码的人看见的信息。明文与密文可以通过加密解密来相互转换。 1）唯密文攻击&emsp;&emsp;在只知道加密后的文字（密文）且不知道明文的情况下进行攻击。 2）已知明文攻击&emsp;&emsp;指攻击者掌握了某段明文和对应的密文，通过若干明密文对获取加密方式，从而破解密文。 3）选择明文攻击&emsp;&emsp;攻击者拥有加密机的访问权限，可构造任意明文所对应的密文。攻击者占有加密机，可以任意选择一定数量的明文，让加密机进行加密，得到响应的密文。攻击者只能使用加密机，并不知道加密算法。攻击者可以利用明文加密成密码的过程，来获得关于加密算法的一些信息，甚至可能直接获得解密用的钥匙。 4）选择密文攻击&emsp;&emsp;攻击者掌握对解密机的访问权限，可构造任意密文所对应的明文。与选择明文攻击类似，同样可以获取明密文对，进而获取解密的信息。 解题过程 网上下载了个Advanced Zip Password Recovery。 讲题目中提供的连个文件下载到本地。sqlmap_plain.zip和sqlmap.zip（加密，内有保存着flag的文件） 加密的zip文件处选择sqlmap.zip路径 攻击类型选择明文攻击。 设置明文文件路径，即sqlmap_plain.zip的路径。 保存解密后的文件，解压得到flag。 PS：使用的软件为破解版，官方正版不注册无法查看秘钥，而且只能解密一个文件。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Forensics2]]></title>
    <url>%2F2019%2F04%2F04%2FForensics2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本以为有了上个题目的经验，这次会好做一点，没想到并不是手到擒来，倒也比之前有突破的方向了。 各种协议&emsp;&emsp;数据包中出现了几个协议，查阅了一下主要作用。 ICMP（Internet Control Message Protocol）是Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网络的连线状况，也能确保连线的准确性。 ARP（Address Resolution Protocol）地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 SSH（Secure Shell）安全外壳协议，是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 NFS（Network File System）网络文件系统，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。 解题思路1）题目中给出提示:something about file，NFS网络文件系统是关于文件访问的，寻找flag很大可能与此有关。 2）数据包分析 前8行，IP为10.0.0.22的主机ping了IP为10.0.0.2的主机四次，均成功得到响应。 9,10行，通过ARP协议，根据IP获取物理地址。 11-13行，三次握手建立TCP连接。 之后，建立SSH安全连接。 通过NFS协议进行文件的交互。（貌似是这样，emmm…） 3）NFS协议分析 过滤出NFS协议 376行，10.0.0.22回复10.0.0.2 [Allowed:RD LU MD XT DL]，即授予10.0.0.2对文件进行的读（READ，RD）、查找（LOOKUP，LU）、修改（MODIFY，MD）、增加（EXTEND，XT）和删除（DELETE，DL）的权限。 378行，查找flag.txt.gz是否存在。 379行，返回查找状态，未找到该文件。 391行，打开flag.txt.gz文件（文件本不存在，应该是先建立后打开的）。 400行，请求对文件进行写操作。 402行，请求关闭文件。 分析400行中进行的写内容，将data导出为zip文件，解压后得到一文本文档，内有flag。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Forensics1]]></title>
    <url>%2F2019%2F04%2F03%2FForensics1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;有点难搞，昨天搞出来，没来得及写博客，今天整理一下。 关于HTTP1）HTTP简介&emsp;&emsp;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 2)HTTP工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP是基于请求响应模式的、无状态的、应用层协议。默认端口号80. 3）HTTP的特点 HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 4）HTTP消息结构 客户端请求消息：请求行、请求头部、空行和请求数据 服务端响应消息：状态行、消息报头、空行和响应正文 5)HTTP请求方法 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 6)HTTP状态码 常见状态码这里不再搬运了，一找一大把、、、 解题实战1）下载安装wireshark打开题目提供的文件，在过滤器中输入过滤条件：http 2）得到入下图： 经三次握手建立连接后，服务器端192.168.245.136向客户端192.168.245.128发送了一个网页，查看源码导出为html页面： 2218行，客户端向服务器请求favicon.ico 2248行，服务器做出响应，返回favicon.ico该图片为： 2252行，客户端在输入框中输入密码”admin”提交 2253行，服务器做出响应Wrong password. 2262行，客户端再次提交密码”test” 2263行，服务器再次做出响应Wrong password. 2272行，客户端提交密码”thisisatest” 2273行，服务器响应了一个页面，页面源码：导出为html文件查看： 3)答案应该就在s3cret图片中 2275行，客服端请求s3cret.png 2277行，服务器响应，返回该图片导出为图片格式，得到flag。 总结与感悟&emsp;&emsp;通过这道题又回顾了一下HTTP协议，了解了一下wireshark软件的使用，收获还是蛮大的。只不过花了一天多的时间，搜集了若干资料，才算勉强搞定。还是蛮有成就感的，hhh、、、太容易自我满足了、、、前面还有不少难关，继续前进咯。 &emsp;&emsp;Ps:没想到整理博客就整理了一上午、、、]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docx]]></title>
    <url>%2F2019%2F04%2F01%2Fdocx%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;隐写题，了解docx文件本质。 &emsp;&emsp;docx是Microsoft Office2007之后版本使用的，用新的基于XML的压缩文件格式取代了其目前专有的默认文件格式，在传统的文件名扩展名后面添加了字母“x”。 &emsp;&emsp;docx格式文件的主要内容是保存为XML格式的，但文件并非直接保存于磁盘。它是保存在一个zip文件中，然后去扩展名为docx。docx格式的文件本质上是一个zip文件。将一个docx文件的后缀改为zip后可以用解压工具打开。 &emsp;&emsp;解压后如图： &emsp;&emsp;打开Flag.xml文件，得到答案。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exif]]></title>
    <url>%2F2019%2F04%2F01%2FExif%2F</url>
    <content type="text"><![CDATA[图片隐写题，编码比较。 &emsp;&emsp;经查阅得知Exif：可交换图像文件格式（Exchangeable image file format），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。emmmm…了解了，照片中蕴含着信息，把这些信息搞出来研究研究。 &emsp;&emsp;在查阅Exif的概念时，发现了一个在线的EXIF信息查看器（https://exif.tuchong.com/ ），将图片上传，得到一堆参数 在给出的集中编码中，随便选择了比较熟悉的ASCII码尝试一下，将flag{}转换为ASCII码，然后查询匹配，最终定位到Credit这一栏。 &emsp;&emsp;运气还不错，这一串数字，转化一下就是答案了。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2019%2F03%2F31%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[笔记本免费科学上网一、1.链接访问https://github.com/shadowsocks/shadowsocks-windows/releases 下载前两个 解压，将Shadowsocks-4.1.5文件夹中的Shadowsocks.exe复制粘贴到shadowsocks-windows-4.1.5文件夹中，双击exe如能运行便可。 我用的是新版本，是上面这么个情况，如果旧版本，第一个文件中解压出来可能会带有连个exe后缀的文件，两个exe都运行试一下，哪个能用用哪个。 2.在我的笔记本直接可以运行使用，如果不能运行的话，访问https://github.com/shadowsocks/shadowsocks-windows 先下载第一个安装，若还不行再下载安装第二个。 3.访问https://free-ss.site/ 获取免费的账号密码，（https://www.ssrtool.com/tool/free_ssr 也可以，不建议大量推广）但是需要提前翻过才可以。可以手机翻出去获取二维码，发送到电脑端扫描，安卓手机FQ很容易。暂且这么用着，并不一定能长久使用，有条件，还是自己搭一个比较好，属于自己的稳定，快速。hhhh、、、 4.右键shadowsocks图标，选择启用系统代理，系统代理模式为全局代理模式，服务器选项中可以配置服务器，建议多添加几个，选择网速的最快的使用。自己感觉服务器位于US的好用些、、、 用完之后一定要记得退出！！！ 二、谷歌浏览器，点击左上角应用，网上应用（直接访问https://chrome.google.com/webstore/category/extensions?h1=zh也可以），搜索skyzip， 将其添加至chrom即可在谷歌浏览器中实现访问外网的功能。地址栏右侧的小图标，点击可以打开关闭FQ模式。网速貌似不咋滴，一般般吧，可能分时段分地区。 Ipad科学上网1.在app store中下载安装Testflight 2.https://testflight.apple.com/join/7U4YKpl2 浏览器中打开此链接（ios系统），下载 寒梅 测试版 3.打开寒梅 添加代理 服务器 端口 密码 加密方式 都可以通过以下链接免费获得（上面已经提到过） https://free-ss.site/ https://www.ssrtool.com/tool/free_ssr 寒梅测试有期限 七八十天的样子 到期再想办法、、、 网上说可以申请美区AppleId登录app store下载shadowsocks（大陆与FQ相关的都已经全体下架）。有点麻烦，有空再尝试一下。 Ps：据说可以发邮件到ss@rohankdd.com询问最新的镜像网站的地址，发送内容为镜像网站之类即可。]]></content>
      <tags>
        <tag>FQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSB]]></title>
    <url>%2F2019%2F03%2F30%2FLSB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;图片隐写题，最低有效位。 &emsp;&emsp;经过多方收集资料，得知解题需要一定的基础和各种工具，于是针对这道题有目的的看了一些博客，大概了解了一下解题的思想，说实话，对于尚未入门的我来说，没有形成解题思维，对常用解题套路一无所知，整起来真的很难受、、、 &emsp;&emsp;在动用工具之前，曾尝试查看照片属性，以文本形式查看图片等方法，无果，嗯，虽然给了提示，但是毫不了解的我还是努力错了方向。然后经了解，得知解这种图片隐写题需要用到Stegsolve，下载下来，摸索着用，根据某些博客上的教程，操作了一遍，把Red、Green、Blue勾选第0位，选择LSB First，Bit Plane Order中的试了一遍，没有找到所谓的flag。很愁人，很崩溃，在门外徘徊，找不到一点儿头绪的感觉很难受。 &emsp;&emsp;晚饭过后，打开Stegsolve点着玩儿，点到Red plane 0时，清晰的二维码出现，扫了一下，拿到flag提交，又充满了信心、、、]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《So you want to work in security?》读后感]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;兴趣是自主学习的第一动力。只有在真正感兴趣的方向，才能够乐于主动投入足够的时间精力来钻研学习。计算机相关的各行业，本身就是新技术层出不穷，需要不断学习不断进步来紧跟发展的步伐。如果没有足够的兴趣来支撑，难以有足够的积极性来应对这些挑战。自己能达到的高度，主要靠自己的努力程度，早就不是初高中那样，有人督促有人安排好计划，自己被推着向前走了。 &emsp;&emsp;原文中提到入门难度较高，对于近乎零基础的我来说，的确如此，学习接受陌生的新鲜知识都会需要一个过程，自己摸索的这个过程可能不会很好受，但一旦坚持下来取得些许小成果儿，那种感觉还是很美妙的。就像绞尽脑汁思考一道编程题，费了好大劲儿终于AC的喜悦感。当自己也具备过硬的技术，才能成为自己所羡慕的大佬、大神。既然选择了，有能力那就努力往前走，向上爬，不留遗憾。 ​]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试一哈]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B5%8B%E8%AF%95%E4%B8%80%E5%93%88%2F</url>
    <content type="text"><![CDATA[这是第一个文章哈哈哈哈 额貌似或暗示哦啊]]></content>
      <tags>
        <tag>tt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
